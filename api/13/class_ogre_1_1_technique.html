<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::Technique Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.2</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_technique.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_technique-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::Technique Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___materials.html">Materials</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class representing an approach to rendering this particular <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a>.  
 <a href="class_ogre_1_1_technique.html#details">More...</a></p>

<p><code>#include &lt;OgreTechnique.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::Technique:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_technique__inherit__graph.svg" width="138" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_technique_1_1_g_p_u_device_name_rule.html">GPUDeviceNameRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule controlling whether technique is deemed supported based on GPU device name.  <a href="struct_ogre_1_1_technique_1_1_g_p_u_device_name_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_technique_1_1_g_p_u_vendor_rule.html">GPUVendorRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule controlling whether technique is deemed supported based on GPU vendor.  <a href="struct_ogre_1_1_technique_1_1_g_p_u_vendor_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a63da4eb10f7272486a9806374b09bab6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_technique.html#a19e4233dcb87fbb8d592133ca7f10626">GPUDeviceNameRuleList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a63da4eb10f7272486a9806374b09bab6">GPUDeviceNameRuleIterator</a></td></tr>
<tr class="separator:a63da4eb10f7272486a9806374b09bab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e4233dcb87fbb8d592133ca7f10626"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="struct_ogre_1_1_technique_1_1_g_p_u_device_name_rule.html">GPUDeviceNameRule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a19e4233dcb87fbb8d592133ca7f10626">GPUDeviceNameRuleList</a></td></tr>
<tr class="separator:a19e4233dcb87fbb8d592133ca7f10626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2497a0043902e9d2af0757d769da655c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_technique.html#a02400e8fcd433054c6559331858a782e">GPUVendorRuleList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a2497a0043902e9d2af0757d769da655c">GPUVendorRuleIterator</a></td></tr>
<tr class="separator:a2497a0043902e9d2af0757d769da655c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02400e8fcd433054c6559331858a782e"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="struct_ogre_1_1_technique_1_1_g_p_u_vendor_rule.html">GPUVendorRule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a02400e8fcd433054c6559331858a782e">GPUVendorRuleList</a></td></tr>
<tr class="separator:a02400e8fcd433054c6559331858a782e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a239a5901d2c67add2e7cea0bf3468"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt; <a class="el" href="group___materials.html#gaff4cf78f2520e56a8c45721e2dc419c9">IlluminationPassList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a77a239a5901d2c67add2e7cea0bf3468">IlluminationPassIterator</a></td></tr>
<tr class="separator:a77a239a5901d2c67add2e7cea0bf3468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ade219e17b5e8d73d079d11f64a2a2d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a> { <a class="el" href="class_ogre_1_1_technique.html#a1ade219e17b5e8d73d079d11f64a2a2dabd4cc2de655eff5194cda7ea50d00ee3">INCLUDE</a> = 0, 
<a class="el" href="class_ogre_1_1_technique.html#a1ade219e17b5e8d73d079d11f64a2a2da043f697946b7a6d01bb858768e6646a3">EXCLUDE</a> = 1
 }</td></tr>
<tr class="memdesc:a1ade219e17b5e8d73d079d11f64a2a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directive used to manually control technique support based on the inclusion or exclusion of some factor.  <a href="class_ogre_1_1_technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">More...</a><br /></td></tr>
<tr class="separator:a1ade219e17b5e8d73d079d11f64a2a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6823bce807c243c04e544ee99eea1d1"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="class_ogre_1_1_pass.html">Pass</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ab6823bce807c243c04e544ee99eea1d1">Passes</a></td></tr>
<tr class="separator:ab6823bce807c243c04e544ee99eea1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4640d3383f331657fd9ee05cb835c2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_technique.html#ab6823bce807c243c04e544ee99eea1d1">Passes</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a3b4640d3383f331657fd9ee05cb835c2">PassIterator</a></td></tr>
<tr class="separator:a3b4640d3383f331657fd9ee05cb835c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4bf5eef2cd88abdf3408234f2bb0899c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a4bf5eef2cd88abdf3408234f2bb0899c">Technique</a> (<a class="el" href="class_ogre_1_1_material.html">Material</a> *parent)</td></tr>
<tr class="memdesc:a4bf5eef2cd88abdf3408234f2bb0899c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_ogre_1_1_technique.html#a4bf5eef2cd88abdf3408234f2bb0899c">More...</a><br /></td></tr>
<tr class="separator:a4bf5eef2cd88abdf3408234f2bb0899c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0fe6b1b297d9c8e81287d7c7a7b377"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a0e0fe6b1b297d9c8e81287d7c7a7b377">Technique</a> (<a class="el" href="class_ogre_1_1_material.html">Material</a> *parent, const <a class="el" href="class_ogre_1_1_technique.html">Technique</a> &amp;oth)</td></tr>
<tr class="memdesc:a0e0fe6b1b297d9c8e81287d7c7a7b377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="class_ogre_1_1_technique.html#a0e0fe6b1b297d9c8e81287d7c7a7b377">More...</a><br /></td></tr>
<tr class="separator:a0e0fe6b1b297d9c8e81287d7c7a7b377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3942999affa2e3a81d122ac58f181f11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a3942999affa2e3a81d122ac58f181f11">~Technique</a> ()</td></tr>
<tr class="separator:a3942999affa2e3a81d122ac58f181f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec5e34e76944eb89ac0c6d370e3b1d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#abec5e34e76944eb89ac0c6d370e3b1d5">_compile</a> (bool autoManageTextureUnits)</td></tr>
<tr class="memdesc:abec5e34e76944eb89ac0c6d370e3b1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal compilation method; see <a class="el" href="class_ogre_1_1_material.html#a1f51926064eaa39f9d85393b41bb8870" title="&#39;Compiles&#39; this Material.">Material::compile</a>.  <a href="class_ogre_1_1_technique.html#abec5e34e76944eb89ac0c6d370e3b1d5">More...</a><br /></td></tr>
<tr class="separator:abec5e34e76944eb89ac0c6d370e3b1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d374e0051b5d0a38ff9232369720a7b"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a8d374e0051b5d0a38ff9232369720a7b">_getSchemeIndex</a> (void) const</td></tr>
<tr class="memdesc:a8d374e0051b5d0a38ff9232369720a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for getting the scheme index.  <a href="class_ogre_1_1_technique.html#a8d374e0051b5d0a38ff9232369720a7b">More...</a><br /></td></tr>
<tr class="separator:a8d374e0051b5d0a38ff9232369720a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b98b4f291fa76b02d2adeb822998af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a92b98b4f291fa76b02d2adeb822998af">_load</a> (void)</td></tr>
<tr class="memdesc:a92b98b4f291fa76b02d2adeb822998af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal load method, derived from call to <a class="el" href="class_ogre_1_1_resource.html#a699d1c851f494a8d5d23d23b695ceb47" title="Loads the resource, if it is not already.">Material::load</a>.  <a href="class_ogre_1_1_technique.html#a92b98b4f291fa76b02d2adeb822998af">More...</a><br /></td></tr>
<tr class="separator:a92b98b4f291fa76b02d2adeb822998af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ad18f720bba21676f3424ed7b2382d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#aa5ad18f720bba21676f3424ed7b2382d">_notifyNeedsRecompile</a> (void)</td></tr>
<tr class="memdesc:aa5ad18f720bba21676f3424ed7b2382d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the technique that it needs recompilation.  <a href="class_ogre_1_1_technique.html#aa5ad18f720bba21676f3424ed7b2382d">More...</a><br /></td></tr>
<tr class="separator:aa5ad18f720bba21676f3424ed7b2382d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5833abf80056c4a18b6eafb137b590bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a5833abf80056c4a18b6eafb137b590bb">_prepare</a> (void)</td></tr>
<tr class="memdesc:a5833abf80056c4a18b6eafb137b590bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal prepare method, derived from call to <a class="el" href="class_ogre_1_1_resource.html#a350b287fa3e83a389221274f68760008" title="Prepares the resource for load, if it is not already.">Material::prepare</a>.  <a href="class_ogre_1_1_technique.html#a5833abf80056c4a18b6eafb137b590bb">More...</a><br /></td></tr>
<tr class="separator:a5833abf80056c4a18b6eafb137b590bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c19a7dd382f37226f307c3afc98794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a73c19a7dd382f37226f307c3afc98794">_unload</a> (void)</td></tr>
<tr class="memdesc:a73c19a7dd382f37226f307c3afc98794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal unload method, derived from call to <a class="el" href="class_ogre_1_1_resource.html#aa31bef1bfaa87731622e56f11b548e27" title="Unloads the resource; this is not permanent, the resource can be reloaded later if required.">Material::unload</a>.  <a href="class_ogre_1_1_technique.html#a73c19a7dd382f37226f307c3afc98794">More...</a><br /></td></tr>
<tr class="separator:a73c19a7dd382f37226f307c3afc98794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f99fe8c81b1dffaf2d9bfc3cfabb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ad78f99fe8c81b1dffaf2d9bfc3cfabb4">_unprepare</a> (void)</td></tr>
<tr class="memdesc:ad78f99fe8c81b1dffaf2d9bfc3cfabb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal unprepare method, derived from call to Material::unprepare.  <a href="class_ogre_1_1_technique.html#ad78f99fe8c81b1dffaf2d9bfc3cfabb4">More...</a><br /></td></tr>
<tr class="separator:ad78f99fe8c81b1dffaf2d9bfc3cfabb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac14534e5754cae83f2769b4c1ebbbd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a9ac14534e5754cae83f2769b4c1ebbbd">calculateSize</a> (void) const</td></tr>
<tr class="separator:a9ac14534e5754cae83f2769b4c1ebbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acb60df20fcd4e4ef5d59c83daff3c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a2acb60df20fcd4e4ef5d59c83daff3c0">checkHardwareSupport</a> (bool autoManageTextureUnits, <a class="el" href="namespace_ogre.html#af9b3423b7c29049c4cfa637d4a41a28f">StringStream</a> &amp;compileErrors)</td></tr>
<tr class="memdesc:a2acb60df20fcd4e4ef5d59c83daff3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for checking hardware support.  <a href="class_ogre_1_1_technique.html#a2acb60df20fcd4e4ef5d59c83daff3c0">More...</a><br /></td></tr>
<tr class="separator:a2acb60df20fcd4e4ef5d59c83daff3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18697c9c5f2bc1f98d3789ca26a6c0ec"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a18697c9c5f2bc1f98d3789ca26a6c0ec">getLodIndex</a> (void) const</td></tr>
<tr class="memdesc:a18697c9c5f2bc1f98d3789ca26a6c0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the level-of-detail index assigned to this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#a18697c9c5f2bc1f98d3789ca26a6c0ec">More...</a><br /></td></tr>
<tr class="separator:a18697c9c5f2bc1f98d3789ca26a6c0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7751c3441cb6cbc1744f29c4ccb63ef0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a7751c3441cb6cbc1744f29c4ccb63ef0">getName</a> (void) const</td></tr>
<tr class="memdesc:a7751c3441cb6cbc1744f29c4ccb63ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the technique.  <a href="class_ogre_1_1_technique.html#a7751c3441cb6cbc1744f29c4ccb63ef0">More...</a><br /></td></tr>
<tr class="separator:a7751c3441cb6cbc1744f29c4ccb63ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cff77dca6020ab98c0cbbc225913f57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_material.html">Material</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a3cff77dca6020ab98c0cbbc225913f57">getParent</a> (void) const</td></tr>
<tr class="memdesc:a3cff77dca6020ab98c0cbbc225913f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a>.  <a href="class_ogre_1_1_technique.html#a3cff77dca6020ab98c0cbbc225913f57">More...</a><br /></td></tr>
<tr class="separator:a3cff77dca6020ab98c0cbbc225913f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7802cd8f4224061fa79d17943c01ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a9c7802cd8f4224061fa79d17943c01ac">getResourceGroup</a> (void) const</td></tr>
<tr class="memdesc:a9c7802cd8f4224061fa79d17943c01ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the resource group of the ultimate parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a>.  <a href="class_ogre_1_1_technique.html#a9c7802cd8f4224061fa79d17943c01ac">More...</a><br /></td></tr>
<tr class="separator:a9c7802cd8f4224061fa79d17943c01ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5472361e875965fa57fa7576f832cc7d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a5472361e875965fa57fa7576f832cc7d">getSchemeName</a> (void) const</td></tr>
<tr class="memdesc:a5472361e875965fa57fa7576f832cc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scheme to which this technique is assigned.  <a href="class_ogre_1_1_technique.html#a5472361e875965fa57fa7576f832cc7d">More...</a><br /></td></tr>
<tr class="separator:a5472361e875965fa57fa7576f832cc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96db53bdf6b3f097fcb9a038df84abe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a96db53bdf6b3f097fcb9a038df84abe9">getUserObjectBindings</a> ()</td></tr>
<tr class="memdesc:a96db53bdf6b3f097fcb9a038df84abe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="class_ogre_1_1_technique.html#a96db53bdf6b3f097fcb9a038df84abe9">More...</a><br /></td></tr>
<tr class="separator:a96db53bdf6b3f097fcb9a038df84abe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd23883c7d06966a259a1490a6b8ffa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a9fd23883c7d06966a259a1490a6b8ffa">getUserObjectBindings</a> () const</td></tr>
<tr class="memdesc:a9fd23883c7d06966a259a1490a6b8ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="class_ogre_1_1_technique.html#a9fd23883c7d06966a259a1490a6b8ffa">More...</a><br /></td></tr>
<tr class="separator:a9fd23883c7d06966a259a1490a6b8ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf1f068b46e9249c6ba4621ef695256"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#aeaf1f068b46e9249c6ba4621ef695256">hasColourWriteDisabled</a> (void) const</td></tr>
<tr class="memdesc:aeaf1f068b46e9249c6ba4621ef695256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exists colour writing disabled pass on this technique?  <a href="class_ogre_1_1_technique.html#aeaf1f068b46e9249c6ba4621ef695256">More...</a><br /></td></tr>
<tr class="separator:aeaf1f068b46e9249c6ba4621ef695256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1efc3fe1d8143d2f5d5d65127c2e27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a5b1efc3fe1d8143d2f5d5d65127c2e27">isDepthCheckEnabled</a> (void) const</td></tr>
<tr class="memdesc:a5b1efc3fe1d8143d2f5d5d65127c2e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is depth checking going to occur on this technique?  <a href="class_ogre_1_1_technique.html#a5b1efc3fe1d8143d2f5d5d65127c2e27">More...</a><br /></td></tr>
<tr class="separator:a5b1efc3fe1d8143d2f5d5d65127c2e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ca213f1f6b4e5de440950f87d16c82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a93ca213f1f6b4e5de440950f87d16c82">isDepthWriteEnabled</a> (void) const</td></tr>
<tr class="memdesc:a93ca213f1f6b4e5de440950f87d16c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is depth writing going to occur on this technique?  <a href="class_ogre_1_1_technique.html#a93ca213f1f6b4e5de440950f87d16c82">More...</a><br /></td></tr>
<tr class="separator:a93ca213f1f6b4e5de440950f87d16c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa387fee443de5a25752ec0af27b215d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#aaa387fee443de5a25752ec0af27b215d">isLoaded</a> (void) const</td></tr>
<tr class="memdesc:aaa387fee443de5a25752ec0af27b215d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this loaded?  <a href="class_ogre_1_1_technique.html#aaa387fee443de5a25752ec0af27b215d">More...</a><br /></td></tr>
<tr class="separator:aaa387fee443de5a25752ec0af27b215d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e262c0765863c31eaaff0cd261b6cfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a3e262c0765863c31eaaff0cd261b6cfa">isSupported</a> (void) const</td></tr>
<tr class="memdesc:a3e262c0765863c31eaaff0cd261b6cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if this technique is supported by the current graphics card.  <a href="class_ogre_1_1_technique.html#a3e262c0765863c31eaaff0cd261b6cfa">More...</a><br /></td></tr>
<tr class="separator:a3e262c0765863c31eaaff0cd261b6cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b43d297b8de412d601b08978519a83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a62b43d297b8de412d601b08978519a83">isTransparent</a> (void) const</td></tr>
<tr class="memdesc:a62b43d297b8de412d601b08978519a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> involves transparency.  <a href="class_ogre_1_1_technique.html#a62b43d297b8de412d601b08978519a83">More...</a><br /></td></tr>
<tr class="separator:a62b43d297b8de412d601b08978519a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100f0393659922c14c06b4cdbf4f2e76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a100f0393659922c14c06b4cdbf4f2e76">isTransparentSortingEnabled</a> (void) const</td></tr>
<tr class="memdesc:a100f0393659922c14c06b4cdbf4f2e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has transparent sorting enabled.  <a href="class_ogre_1_1_technique.html#a100f0393659922c14c06b4cdbf4f2e76">More...</a><br /></td></tr>
<tr class="separator:a100f0393659922c14c06b4cdbf4f2e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373450226634c5316e9523a006112274"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a373450226634c5316e9523a006112274">isTransparentSortingForced</a> (void) const</td></tr>
<tr class="memdesc:a373450226634c5316e9523a006112274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has transparent sorting forced.  <a href="class_ogre_1_1_technique.html#a373450226634c5316e9523a006112274">More...</a><br /></td></tr>
<tr class="separator:a373450226634c5316e9523a006112274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac251efbed20452a6efb1361ea5d27496"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_technique.html">Technique</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ac251efbed20452a6efb1361ea5d27496">operator=</a> (const <a class="el" href="class_ogre_1_1_technique.html">Technique</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac251efbed20452a6efb1361ea5d27496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded operator to copy on <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> to another.  <a href="class_ogre_1_1_technique.html#ac251efbed20452a6efb1361ea5d27496">More...</a><br /></td></tr>
<tr class="separator:ac251efbed20452a6efb1361ea5d27496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72db7823cc9a8e872aed1ca6ae2cff8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ab72db7823cc9a8e872aed1ca6ae2cff8">setLodIndex</a> (unsigned short index)</td></tr>
<tr class="memdesc:ab72db7823cc9a8e872aed1ca6ae2cff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a level-of-detail (LOD) index to this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#ab72db7823cc9a8e872aed1ca6ae2cff8">More...</a><br /></td></tr>
<tr class="separator:ab72db7823cc9a8e872aed1ca6ae2cff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365b0e6313b646d0ecc13c1c52a6d3ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a365b0e6313b646d0ecc13c1c52a6d3ad">setName</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name)</td></tr>
<tr class="memdesc:a365b0e6313b646d0ecc13c1c52a6d3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of the technique.  <a href="class_ogre_1_1_technique.html#a365b0e6313b646d0ecc13c1c52a6d3ad">More...</a><br /></td></tr>
<tr class="separator:a365b0e6313b646d0ecc13c1c52a6d3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b6c4e9e48c4e56f96633b916ee90a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a43b6c4e9e48c4e56f96633b916ee90a3">setSchemeName</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName)</td></tr>
<tr class="memdesc:a43b6c4e9e48c4e56f96633b916ee90a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the 'scheme name' for this technique.  <a href="class_ogre_1_1_technique.html#a43b6c4e9e48c4e56f96633b916ee90a3">More...</a><br /></td></tr>
<tr class="separator:a43b6c4e9e48c4e56f96633b916ee90a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Passes</div></td></tr>
<tr class="memitem:a51466b61bfe2dbcdb1afbf21b1dd3253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_pass.html">Pass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a51466b61bfe2dbcdb1afbf21b1dd3253">createPass</a> (void)</td></tr>
<tr class="memdesc:a51466b61bfe2dbcdb1afbf21b1dd3253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> for this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#a51466b61bfe2dbcdb1afbf21b1dd3253">More...</a><br /></td></tr>
<tr class="separator:a51466b61bfe2dbcdb1afbf21b1dd3253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8712d608bb9270821c67326369750a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_pass.html">Pass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#aa8712d608bb9270821c67326369750a2">getPass</a> (size_t index) const</td></tr>
<tr class="memdesc:aa8712d608bb9270821c67326369750a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the given index.  <a href="class_ogre_1_1_technique.html#aa8712d608bb9270821c67326369750a2">More...</a><br /></td></tr>
<tr class="separator:aa8712d608bb9270821c67326369750a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46354c01abc4f183088300551c51b2a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_pass.html">Pass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a46354c01abc4f183088300551c51b2a5">getPass</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name) const</td></tr>
<tr class="memdesc:a46354c01abc4f183088300551c51b2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> matching name.  <a href="class_ogre_1_1_technique.html#a46354c01abc4f183088300551c51b2a5">More...</a><br /></td></tr>
<tr class="separator:a46354c01abc4f183088300551c51b2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6bd0bd4989f866dc423f1a78f3ff23"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a5a6bd0bd4989f866dc423f1a78f3ff23">getNumPasses</a> (void) const</td></tr>
<tr class="memdesc:a5a6bd0bd4989f866dc423f1a78f3ff23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of passes.  <a href="class_ogre_1_1_technique.html#a5a6bd0bd4989f866dc423f1a78f3ff23">More...</a><br /></td></tr>
<tr class="separator:a5a6bd0bd4989f866dc423f1a78f3ff23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cff3e7cbf0b677433ca0a0da04c6aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#af6cff3e7cbf0b677433ca0a0da04c6aa">removePass</a> (unsigned short index)</td></tr>
<tr class="memdesc:af6cff3e7cbf0b677433ca0a0da04c6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the given index.  <a href="class_ogre_1_1_technique.html#af6cff3e7cbf0b677433ca0a0da04c6aa">More...</a><br /></td></tr>
<tr class="separator:af6cff3e7cbf0b677433ca0a0da04c6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaae1583cf2e6e310ae911d34da00be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a1eaae1583cf2e6e310ae911d34da00be">removeAllPasses</a> (void)</td></tr>
<tr class="memdesc:a1eaae1583cf2e6e310ae911d34da00be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all Passes from this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#a1eaae1583cf2e6e310ae911d34da00be">More...</a><br /></td></tr>
<tr class="separator:a1eaae1583cf2e6e310ae911d34da00be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe998209ba33ea38fdcef68743d678c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a6fe998209ba33ea38fdcef68743d678c">movePass</a> (const unsigned short sourceIndex, const unsigned short destinationIndex)</td></tr>
<tr class="memdesc:a6fe998209ba33ea38fdcef68743d678c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a pass from source index to destination index.  <a href="class_ogre_1_1_technique.html#a6fe998209ba33ea38fdcef68743d678c">More...</a><br /></td></tr>
<tr class="separator:a6fe998209ba33ea38fdcef68743d678c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f0ff4e856f6965c7ae8dcab67e6cf2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_technique.html#a3b4640d3383f331657fd9ee05cb835c2">PassIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a84f0ff4e856f6965c7ae8dcab67e6cf2">getPassIterator</a> (void)</td></tr>
<tr class="memdesc:a84f0ff4e856f6965c7ae8dcab67e6cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an iterator over the passes in this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#a84f0ff4e856f6965c7ae8dcab67e6cf2">More...</a><br /></td></tr>
<tr class="separator:a84f0ff4e856f6965c7ae8dcab67e6cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eea3c6d9d68dbd7297e478b4e8e487c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_technique.html#ab6823bce807c243c04e544ee99eea1d1">Passes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a0eea3c6d9d68dbd7297e478b4e8e487c">getPasses</a> (void) const</td></tr>
<tr class="memdesc:a0eea3c6d9d68dbd7297e478b4e8e487c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the passes in this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#a0eea3c6d9d68dbd7297e478b4e8e487c">More...</a><br /></td></tr>
<tr class="separator:a0eea3c6d9d68dbd7297e478b4e8e487c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67fd3f320d1541d07cb6c65e58f4892"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___materials.html#gaff4cf78f2520e56a8c45721e2dc419c9">IlluminationPassList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ac67fd3f320d1541d07cb6c65e58f4892">getIlluminationPasses</a> ()</td></tr>
<tr class="memdesc:ac67fd3f320d1541d07cb6c65e58f4892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the illumination-stage categorised passes.  <a href="class_ogre_1_1_technique.html#ac67fd3f320d1541d07cb6c65e58f4892">More...</a><br /></td></tr>
<tr class="separator:ac67fd3f320d1541d07cb6c65e58f4892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8143f16e1759f3b5731389d59a66f309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a8143f16e1759f3b5731389d59a66f309">_compileIlluminationPasses</a> (void)</td></tr>
<tr class="memdesc:a8143f16e1759f3b5731389d59a66f309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for splitting the passes into illumination passes.  <a href="class_ogre_1_1_technique.html#a8143f16e1759f3b5731389d59a66f309">More...</a><br /></td></tr>
<tr class="separator:a8143f16e1759f3b5731389d59a66f309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shadow Materials</div></td></tr>
<tr class="memitem:a46eb3d05e2415ed230c22354ee35773f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a46eb3d05e2415ed230c22354ee35773f">getShadowCasterMaterial</a> () const</td></tr>
<tr class="memdesc:a46eb3d05e2415ed230c22354ee35773f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return this material specific shadow casting specific material  <a href="class_ogre_1_1_technique.html#a46eb3d05e2415ed230c22354ee35773f">More...</a><br /></td></tr>
<tr class="separator:a46eb3d05e2415ed230c22354ee35773f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93274a8faed940081fed34616fd87412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a93274a8faed940081fed34616fd87412">setShadowCasterMaterial</a> (<a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a> val)</td></tr>
<tr class="memdesc:a93274a8faed940081fed34616fd87412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the details of the material to use when rendering as a shadow caster.  <a href="class_ogre_1_1_technique.html#a93274a8faed940081fed34616fd87412">More...</a><br /></td></tr>
<tr class="separator:a93274a8faed940081fed34616fd87412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249a188a0fcafa693e44b9ef3f816261"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a249a188a0fcafa693e44b9ef3f816261">setShadowCasterMaterial</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name)</td></tr>
<tr class="memdesc:a249a188a0fcafa693e44b9ef3f816261"><td class="mdescLeft">&#160;</td><td class="mdescRight">set this material specific shadow casting specific material  <a href="class_ogre_1_1_technique.html#a249a188a0fcafa693e44b9ef3f816261">More...</a><br /></td></tr>
<tr class="separator:a249a188a0fcafa693e44b9ef3f816261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f858e45ae918594cd839fee6a8ea01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a72f858e45ae918594cd839fee6a8ea01">getShadowReceiverMaterial</a> () const</td></tr>
<tr class="memdesc:a72f858e45ae918594cd839fee6a8ea01"><td class="mdescLeft">&#160;</td><td class="mdescRight">return this material specific shadow receiving specific material  <a href="class_ogre_1_1_technique.html#a72f858e45ae918594cd839fee6a8ea01">More...</a><br /></td></tr>
<tr class="separator:a72f858e45ae918594cd839fee6a8ea01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d84f017481fd660864627a1952122b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a87d84f017481fd660864627a1952122b">setShadowReceiverMaterial</a> (<a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a> val)</td></tr>
<tr class="memdesc:a87d84f017481fd660864627a1952122b"><td class="mdescLeft">&#160;</td><td class="mdescRight">set this material specific shadow receiving specific material  <a href="class_ogre_1_1_technique.html#a87d84f017481fd660864627a1952122b">More...</a><br /></td></tr>
<tr class="separator:a87d84f017481fd660864627a1952122b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac620a86db8a55ac2124b5f599a2a9a9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ac620a86db8a55ac2124b5f599a2a9a9a">setShadowReceiverMaterial</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;name)</td></tr>
<tr class="memdesc:ac620a86db8a55ac2124b5f599a2a9a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set this material specific shadow receiving specific material  <a href="class_ogre_1_1_technique.html#ac620a86db8a55ac2124b5f599a2a9a9a">More...</a><br /></td></tr>
<tr class="separator:ac620a86db8a55ac2124b5f599a2a9a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Forwarded Pass Properties</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The following methods are to make migration from previous versions simpler and to make code easier to write when dealing with simple materials They set the properties which have been moved to <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> for all Techniques and all Passes </p>
</div></td></tr>
<tr class="memitem:a1b7d1d264b34c50b7606c646415a50e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a1b7d1d264b34c50b7606c646415a50e8">setPointSize</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> ps)</td></tr>
<tr class="memdesc:a1b7d1d264b34c50b7606c646415a50e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the point size properties for every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#a1b7d1d264b34c50b7606c646415a50e8">More...</a><br /></td></tr>
<tr class="separator:a1b7d1d264b34c50b7606c646415a50e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fd76b7e6899ba9f3c302160b392db2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ab4fd76b7e6899ba9f3c302160b392db2">setAmbient</a> (float red, float green, float blue)</td></tr>
<tr class="memdesc:ab4fd76b7e6899ba9f3c302160b392db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ambient colour reflectance properties for every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in every <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#ab4fd76b7e6899ba9f3c302160b392db2">More...</a><br /></td></tr>
<tr class="separator:ab4fd76b7e6899ba9f3c302160b392db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d459624ede01672c78846825cc0f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ac5d459624ede01672c78846825cc0f96">setAmbient</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;ambient)</td></tr>
<tr class="memdesc:ac5d459624ede01672c78846825cc0f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_technique.html#ac5d459624ede01672c78846825cc0f96">More...</a><br /></td></tr>
<tr class="separator:ac5d459624ede01672c78846825cc0f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290b26bac425c362ad25278ff19117bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a290b26bac425c362ad25278ff19117bf">setDiffuse</a> (float red, float green, float blue, float alpha)</td></tr>
<tr class="memdesc:a290b26bac425c362ad25278ff19117bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the diffuse colour reflectance properties of every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in every <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#a290b26bac425c362ad25278ff19117bf">More...</a><br /></td></tr>
<tr class="separator:a290b26bac425c362ad25278ff19117bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e13d58c70bbeeb1708e1479185a959"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#af5e13d58c70bbeeb1708e1479185a959">setDiffuse</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;diffuse)</td></tr>
<tr class="memdesc:af5e13d58c70bbeeb1708e1479185a959"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_technique.html#af5e13d58c70bbeeb1708e1479185a959">More...</a><br /></td></tr>
<tr class="separator:af5e13d58c70bbeeb1708e1479185a959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9302152c679910610981ba42cae926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a8a9302152c679910610981ba42cae926">setSpecular</a> (float red, float green, float blue, float alpha)</td></tr>
<tr class="memdesc:a8a9302152c679910610981ba42cae926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specular colour reflectance properties of every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in every <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#a8a9302152c679910610981ba42cae926">More...</a><br /></td></tr>
<tr class="separator:a8a9302152c679910610981ba42cae926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0add9d092f47eb2b654d936a66902d00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a0add9d092f47eb2b654d936a66902d00">setSpecular</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;specular)</td></tr>
<tr class="memdesc:a0add9d092f47eb2b654d936a66902d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_technique.html#a0add9d092f47eb2b654d936a66902d00">More...</a><br /></td></tr>
<tr class="separator:a0add9d092f47eb2b654d936a66902d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed27a55db91366ee2f95a608f946bc86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#aed27a55db91366ee2f95a608f946bc86">setShininess</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> val)</td></tr>
<tr class="memdesc:aed27a55db91366ee2f95a608f946bc86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the shininess properties of every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in every <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#aed27a55db91366ee2f95a608f946bc86">More...</a><br /></td></tr>
<tr class="separator:aed27a55db91366ee2f95a608f946bc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff783d9452b6787a0fdbf83fd8ea0b33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#aff783d9452b6787a0fdbf83fd8ea0b33">setSelfIllumination</a> (float red, float green, float blue)</td></tr>
<tr class="memdesc:aff783d9452b6787a0fdbf83fd8ea0b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the amount of self-illumination of every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in every <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>.  <a href="class_ogre_1_1_technique.html#aff783d9452b6787a0fdbf83fd8ea0b33">More...</a><br /></td></tr>
<tr class="separator:aff783d9452b6787a0fdbf83fd8ea0b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5d7120bf501c5796bb461ec16ca22d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a9e5d7120bf501c5796bb461ec16ca22d">setSelfIllumination</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;selfIllum)</td></tr>
<tr class="memdesc:a9e5d7120bf501c5796bb461ec16ca22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_technique.html#a9e5d7120bf501c5796bb461ec16ca22d">More...</a><br /></td></tr>
<tr class="separator:a9e5d7120bf501c5796bb461ec16ca22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccefe2b6bb5b6e66e2dcb081f92847f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a8ccefe2b6bb5b6e66e2dcb081f92847f">setDepthCheckEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a8ccefe2b6bb5b6e66e2dcb081f92847f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not each <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> renders with depth-buffer checking on or not.  <a href="class_ogre_1_1_technique.html#a8ccefe2b6bb5b6e66e2dcb081f92847f">More...</a><br /></td></tr>
<tr class="separator:a8ccefe2b6bb5b6e66e2dcb081f92847f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ab42d4b777c0782a2d0170ae5a0970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a17ab42d4b777c0782a2d0170ae5a0970">setDepthWriteEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a17ab42d4b777c0782a2d0170ae5a0970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not each <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> renders with depth-buffer writing on or not.  <a href="class_ogre_1_1_technique.html#a17ab42d4b777c0782a2d0170ae5a0970">More...</a><br /></td></tr>
<tr class="separator:a17ab42d4b777c0782a2d0170ae5a0970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8f52bd7bc067a8f6dac99757063a06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a1f8f52bd7bc067a8f6dac99757063a06">setDepthFunction</a> (<a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a> func)</td></tr>
<tr class="memdesc:a1f8f52bd7bc067a8f6dac99757063a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the function used to compare depth values when depth checking is on.  <a href="class_ogre_1_1_technique.html#a1f8f52bd7bc067a8f6dac99757063a06">More...</a><br /></td></tr>
<tr class="separator:a1f8f52bd7bc067a8f6dac99757063a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155d2bb172e767eab0880667b8669057"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a155d2bb172e767eab0880667b8669057">setColourWriteEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:a155d2bb172e767eab0880667b8669057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not colour buffer writing is enabled for each <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="class_ogre_1_1_technique.html#a155d2bb172e767eab0880667b8669057">More...</a><br /></td></tr>
<tr class="separator:a155d2bb172e767eab0880667b8669057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dabe8ffdef677134ba9514bf3c2895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a28dabe8ffdef677134ba9514bf3c2895">setColourWriteEnabled</a> (bool red, bool green, bool blue, bool alpha)</td></tr>
<tr class="memdesc:a28dabe8ffdef677134ba9514bf3c2895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets which colour buffer channels are enabled for writing for each <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="class_ogre_1_1_technique.html#a28dabe8ffdef677134ba9514bf3c2895">More...</a><br /></td></tr>
<tr class="separator:a28dabe8ffdef677134ba9514bf3c2895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ab7639e71d6118834a9164a7c1c8f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ae3ab7639e71d6118834a9164a7c1c8f9">setCullingMode</a> (<a class="el" href="group___general.html#ga4766f4c65e0a47f0a71c5908944a7a3c">CullingMode</a> mode)</td></tr>
<tr class="memdesc:ae3ab7639e71d6118834a9164a7c1c8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the culling mode for each pass based on the 'vertex winding'.  <a href="class_ogre_1_1_technique.html#ae3ab7639e71d6118834a9164a7c1c8f9">More...</a><br /></td></tr>
<tr class="separator:ae3ab7639e71d6118834a9164a7c1c8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9340f9b31f6189e28d62ab00937ab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a9d9340f9b31f6189e28d62ab00937ab0">setManualCullingMode</a> (<a class="el" href="group___general.html#ga67144aea217e56725c43541fb064af20">ManualCullingMode</a> mode)</td></tr>
<tr class="memdesc:a9d9340f9b31f6189e28d62ab00937ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the manual culling mode, performed by CPU rather than hardware.  <a href="class_ogre_1_1_technique.html#a9d9340f9b31f6189e28d62ab00937ab0">More...</a><br /></td></tr>
<tr class="separator:a9d9340f9b31f6189e28d62ab00937ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f31b910ad3b0a22219210290622482"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ab6f31b910ad3b0a22219210290622482">setLightingEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:ab6f31b910ad3b0a22219210290622482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not dynamic lighting is enabled for every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="class_ogre_1_1_technique.html#ab6f31b910ad3b0a22219210290622482">More...</a><br /></td></tr>
<tr class="separator:ab6f31b910ad3b0a22219210290622482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3bb63365c701842d4539e32cc1480e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a4c3bb63365c701842d4539e32cc1480e">setShadingMode</a> (<a class="el" href="group___general.html#ga12cb29cae690b696c0f1c4863d8c25a7">ShadeOptions</a> mode)</td></tr>
<tr class="memdesc:a4c3bb63365c701842d4539e32cc1480e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of light shading required.  <a href="class_ogre_1_1_technique.html#a4c3bb63365c701842d4539e32cc1480e">More...</a><br /></td></tr>
<tr class="separator:a4c3bb63365c701842d4539e32cc1480e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341545383916252e51c508139903574a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a341545383916252e51c508139903574a">setFog</a> (bool overrideScene, <a class="el" href="group___general.html#ga6467b107ce81cc71b8f2960409f7d897">FogMode</a> mode=<a class="el" href="group___general.html#gga6467b107ce81cc71b8f2960409f7d897ab7793a21880052c0214d4cc040992310">FOG_NONE</a>, const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;colour=<a class="el" href="class_ogre_1_1_colour_value.html#a8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a>, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> expDensity=0.001f, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearStart=0.0f, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> linearEnd=1.0f)</td></tr>
<tr class="memdesc:a341545383916252e51c508139903574a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fogging mode applied to each pass.  <a href="class_ogre_1_1_technique.html#a341545383916252e51c508139903574a">More...</a><br /></td></tr>
<tr class="separator:a341545383916252e51c508139903574a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b4e86384ca3e7a9f03c3fb2a5b3f0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a58b4e86384ca3e7a9f03c3fb2a5b3f0d">setDepthBias</a> (float constantBias, float slopeScaleBias)</td></tr>
<tr class="memdesc:a58b4e86384ca3e7a9f03c3fb2a5b3f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the depth bias to be used for each <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="class_ogre_1_1_technique.html#a58b4e86384ca3e7a9f03c3fb2a5b3f0d">More...</a><br /></td></tr>
<tr class="separator:a58b4e86384ca3e7a9f03c3fb2a5b3f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d7464ef321b859c33c3c1e9334c5f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a67d7464ef321b859c33c3c1e9334c5f2">setTextureFiltering</a> (<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5">TextureFilterOptions</a> filterType)</td></tr>
<tr class="memdesc:a67d7464ef321b859c33c3c1e9334c5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set texture filtering for every texture unit in every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>.  <a href="class_ogre_1_1_technique.html#a67d7464ef321b859c33c3c1e9334c5f2">More...</a><br /></td></tr>
<tr class="separator:a67d7464ef321b859c33c3c1e9334c5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e62cb6b00f8ae9e9da077d0ecc08ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a60e62cb6b00f8ae9e9da077d0ecc08ec">setTextureAnisotropy</a> (unsigned int maxAniso)</td></tr>
<tr class="memdesc:a60e62cb6b00f8ae9e9da077d0ecc08ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the anisotropy level to be used for all textures.  <a href="class_ogre_1_1_technique.html#a60e62cb6b00f8ae9e9da077d0ecc08ec">More...</a><br /></td></tr>
<tr class="separator:a60e62cb6b00f8ae9e9da077d0ecc08ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d44a97049862fc9c5eb64caf5cbbc2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a8d44a97049862fc9c5eb64caf5cbbc2f">setSceneBlending</a> (const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbt)</td></tr>
<tr class="memdesc:a8d44a97049862fc9c5eb64caf5cbbc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the kind of blending every pass has with the existing contents of the scene.  <a href="class_ogre_1_1_technique.html#a8d44a97049862fc9c5eb64caf5cbbc2f">More...</a><br /></td></tr>
<tr class="separator:a8d44a97049862fc9c5eb64caf5cbbc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4cd758dc843921da3a331bcc1bee1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#add4cd758dc843921da3a331bcc1bee1d">setSeparateSceneBlending</a> (const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbt, const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a> sbta)</td></tr>
<tr class="memdesc:add4cd758dc843921da3a331bcc1bee1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the kind of blending every pass has with the existing contents of the scene, using individual factors both color and alpha channels.  <a href="class_ogre_1_1_technique.html#add4cd758dc843921da3a331bcc1bee1d">More...</a><br /></td></tr>
<tr class="separator:add4cd758dc843921da3a331bcc1bee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50815d7c51c153e2a6ab1b581507d28f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a50815d7c51c153e2a6ab1b581507d28f">setSceneBlending</a> (const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactor, const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactor)</td></tr>
<tr class="memdesc:a50815d7c51c153e2a6ab1b581507d28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows very fine control of blending every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the existing contents of the scene.  <a href="class_ogre_1_1_technique.html#a50815d7c51c153e2a6ab1b581507d28f">More...</a><br /></td></tr>
<tr class="separator:a50815d7c51c153e2a6ab1b581507d28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df9ffbf40cbce69799b3be95cf4b701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a5df9ffbf40cbce69799b3be95cf4b701">setSeparateSceneBlending</a> (const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactor, const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactor, const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> sourceFactorAlpha, const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a> destFactorAlpha)</td></tr>
<tr class="memdesc:a5df9ffbf40cbce69799b3be95cf4b701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows very fine control of blending every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the existing contents of the scene, using individual factors both color and alpha channels.  <a href="class_ogre_1_1_technique.html#a5df9ffbf40cbce69799b3be95cf4b701">More...</a><br /></td></tr>
<tr class="separator:a5df9ffbf40cbce69799b3be95cf4b701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">GPU Vendor Rules</div></td></tr>
<tr class="memitem:a67154e6706213a946623bef7f2b65450"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a67154e6706213a946623bef7f2b65450">checkGPURules</a> (<a class="el" href="namespace_ogre.html#af9b3423b7c29049c4cfa637d4a41a28f">StringStream</a> &amp;errors)</td></tr>
<tr class="memdesc:a67154e6706213a946623bef7f2b65450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for checking GPU vendor / device rules.  <a href="class_ogre_1_1_technique.html#a67154e6706213a946623bef7f2b65450">More...</a><br /></td></tr>
<tr class="separator:a67154e6706213a946623bef7f2b65450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3b09baa8cd8566f994ad4ee5d125d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#afe3b09baa8cd8566f994ad4ee5d125d1">addGPUVendorRule</a> (<a class="el" href="group___render_system.html#gac4c251bcc05376f701348bfe0f4a53b4">GPUVendor</a> vendor, <a class="el" href="class_ogre_1_1_technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a> includeOrExclude)</td></tr>
<tr class="memdesc:afe3b09baa8cd8566f994ad4ee5d125d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule which manually influences the support for this technique based on a GPU vendor.  <a href="class_ogre_1_1_technique.html#afe3b09baa8cd8566f994ad4ee5d125d1">More...</a><br /></td></tr>
<tr class="separator:afe3b09baa8cd8566f994ad4ee5d125d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a82a8dedd6ecc9228e392aec08bd52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ac6a82a8dedd6ecc9228e392aec08bd52">addGPUVendorRule</a> (const <a class="el" href="struct_ogre_1_1_technique_1_1_g_p_u_vendor_rule.html">GPUVendorRule</a> &amp;rule)</td></tr>
<tr class="memdesc:ac6a82a8dedd6ecc9228e392aec08bd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule which manually influences the support for this technique based on a GPU vendor.  <a href="class_ogre_1_1_technique.html#ac6a82a8dedd6ecc9228e392aec08bd52">More...</a><br /></td></tr>
<tr class="separator:ac6a82a8dedd6ecc9228e392aec08bd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaadeb93509d6fc3ca27686ca83e76be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#aeaadeb93509d6fc3ca27686ca83e76be">removeGPUVendorRule</a> (<a class="el" href="group___render_system.html#gac4c251bcc05376f701348bfe0f4a53b4">GPUVendor</a> vendor)</td></tr>
<tr class="memdesc:aeaadeb93509d6fc3ca27686ca83e76be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a matching vendor rule.  <a href="class_ogre_1_1_technique.html#aeaadeb93509d6fc3ca27686ca83e76be">More...</a><br /></td></tr>
<tr class="separator:aeaadeb93509d6fc3ca27686ca83e76be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bae44184a980abc5c1fad546781c22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_technique.html#a2497a0043902e9d2af0757d769da655c">GPUVendorRuleIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a87bae44184a980abc5c1fad546781c22">getGPUVendorRuleIterator</a> () const</td></tr>
<tr class="separator:a87bae44184a980abc5c1fad546781c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f207095e9bbda9dde11227756c1e8e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_technique.html#a02400e8fcd433054c6559331858a782e">GPUVendorRuleList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a5f207095e9bbda9dde11227756c1e8e8">getGPUVendorRules</a> () const</td></tr>
<tr class="memdesc:a5f207095e9bbda9dde11227756c1e8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently registered vendor rules.  <a href="class_ogre_1_1_technique.html#a5f207095e9bbda9dde11227756c1e8e8">More...</a><br /></td></tr>
<tr class="separator:a5f207095e9bbda9dde11227756c1e8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6be978dbdbe321f7e8e9803aa29c2d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ab6be978dbdbe321f7e8e9803aa29c2d1">addGPUDeviceNameRule</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;devicePattern, <a class="el" href="class_ogre_1_1_technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a> includeOrExclude, bool caseSensitive=false)</td></tr>
<tr class="memdesc:ab6be978dbdbe321f7e8e9803aa29c2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g.  <a href="class_ogre_1_1_technique.html#ab6be978dbdbe321f7e8e9803aa29c2d1">More...</a><br /></td></tr>
<tr class="separator:ab6be978dbdbe321f7e8e9803aa29c2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b1efd013753818ae29fd15a27c9744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#ad0b1efd013753818ae29fd15a27c9744">addGPUDeviceNameRule</a> (const <a class="el" href="struct_ogre_1_1_technique_1_1_g_p_u_device_name_rule.html">GPUDeviceNameRule</a> &amp;rule)</td></tr>
<tr class="memdesc:ad0b1efd013753818ae29fd15a27c9744"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_technique.html#ad0b1efd013753818ae29fd15a27c9744">More...</a><br /></td></tr>
<tr class="separator:ad0b1efd013753818ae29fd15a27c9744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593e0e3c8e9d7a43155be8c6fdbfa8f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a593e0e3c8e9d7a43155be8c6fdbfa8f7">removeGPUDeviceNameRule</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;devicePattern)</td></tr>
<tr class="memdesc:a593e0e3c8e9d7a43155be8c6fdbfa8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a matching device name rule.  <a href="class_ogre_1_1_technique.html#a593e0e3c8e9d7a43155be8c6fdbfa8f7">More...</a><br /></td></tr>
<tr class="separator:a593e0e3c8e9d7a43155be8c6fdbfa8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8220d069967117f15e63a236e221c6a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_technique.html#a63da4eb10f7272486a9806374b09bab6">GPUDeviceNameRuleIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a8220d069967117f15e63a236e221c6a2">getGPUDeviceNameRuleIterator</a> () const</td></tr>
<tr class="separator:a8220d069967117f15e63a236e221c6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb4cc2bde522445d8d4548e6c6697d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_technique.html#a19e4233dcb87fbb8d592133ca7f10626">GPUDeviceNameRuleList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_technique.html#a0fb4cc2bde522445d8d4548e6c6697d4">getGPUDeviceNameRules</a> () const</td></tr>
<tr class="memdesc:a0fb4cc2bde522445d8d4548e6c6697d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently registered device name rules.  <a href="class_ogre_1_1_technique.html#a0fb4cc2bde522445d8d4548e6c6697d4">More...</a><br /></td></tr>
<tr class="separator:a0fb4cc2bde522445d8d4548e6c6697d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing an approach to rendering this particular <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="namespace_ogre.html">Ogre</a> will attempt to use the best technique supported by the active hardware, unless you specifically request a lower detail technique (say for distant rendering). </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab6823bce807c243c04e544ee99eea1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6823bce807c243c04e544ee99eea1d1">&#9670;&nbsp;</a></span>Passes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="class_ogre_1_1_pass.html">Pass</a>*&gt; <a class="el" href="class_ogre_1_1_technique.html#ab6823bce807c243c04e544ee99eea1d1">Ogre::Technique::Passes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02400e8fcd433054c6559331858a782e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02400e8fcd433054c6559331858a782e">&#9670;&nbsp;</a></span>GPUVendorRuleList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_ogre_1_1_technique_1_1_g_p_u_vendor_rule.html">GPUVendorRule</a>&gt; <a class="el" href="class_ogre_1_1_technique.html#a02400e8fcd433054c6559331858a782e">Ogre::Technique::GPUVendorRuleList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19e4233dcb87fbb8d592133ca7f10626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e4233dcb87fbb8d592133ca7f10626">&#9670;&nbsp;</a></span>GPUDeviceNameRuleList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_ogre_1_1_technique_1_1_g_p_u_device_name_rule.html">GPUDeviceNameRule</a>&gt; <a class="el" href="class_ogre_1_1_technique.html#a19e4233dcb87fbb8d592133ca7f10626">Ogre::Technique::GPUDeviceNameRuleList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b4640d3383f331657fd9ee05cb835c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b4640d3383f331657fd9ee05cb835c2">&#9670;&nbsp;</a></span>PassIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_technique.html#ab6823bce807c243c04e544ee99eea1d1">Passes</a>&gt; <a class="el" href="class_ogre_1_1_technique.html#a3b4640d3383f331657fd9ee05cb835c2">Ogre::Technique::PassIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77a239a5901d2c67add2e7cea0bf3468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a239a5901d2c67add2e7cea0bf3468">&#9670;&nbsp;</a></span>IlluminationPassIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt;<a class="el" href="group___materials.html#gaff4cf78f2520e56a8c45721e2dc419c9">IlluminationPassList</a>&gt; <a class="el" href="class_ogre_1_1_technique.html#a77a239a5901d2c67add2e7cea0bf3468">Ogre::Technique::IlluminationPassIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2497a0043902e9d2af0757d769da655c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2497a0043902e9d2af0757d769da655c">&#9670;&nbsp;</a></span>GPUVendorRuleIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_technique.html#a02400e8fcd433054c6559331858a782e">GPUVendorRuleList</a>&gt; <a class="el" href="class_ogre_1_1_technique.html#a2497a0043902e9d2af0757d769da655c">Ogre::Technique::GPUVendorRuleIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63da4eb10f7272486a9806374b09bab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63da4eb10f7272486a9806374b09bab6">&#9670;&nbsp;</a></span>GPUDeviceNameRuleIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_const_vector_iterator.html">ConstVectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_technique.html#a19e4233dcb87fbb8d592133ca7f10626">GPUDeviceNameRuleList</a>&gt; <a class="el" href="class_ogre_1_1_technique.html#a63da4eb10f7272486a9806374b09bab6">Ogre::Technique::GPUDeviceNameRuleIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a1ade219e17b5e8d73d079d11f64a2a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ade219e17b5e8d73d079d11f64a2a2d">&#9670;&nbsp;</a></span>IncludeOrExclude</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ogre_1_1_technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">Ogre::Technique::IncludeOrExclude</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directive used to manually control technique support based on the inclusion or exclusion of some factor. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1ade219e17b5e8d73d079d11f64a2a2dabd4cc2de655eff5194cda7ea50d00ee3"></a>INCLUDE&#160;</td><td class="fielddoc"><p>Inclusive - only support if present. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1ade219e17b5e8d73d079d11f64a2a2da043f697946b7a6d01bb858768e6646a3"></a>EXCLUDE&#160;</td><td class="fielddoc"><p>Exclusive - do not support if present. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4bf5eef2cd88abdf3408234f2bb0899c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf5eef2cd88abdf3408234f2bb0899c">&#9670;&nbsp;</a></span>Technique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Technique::Technique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_material.html">Material</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a0e0fe6b1b297d9c8e81287d7c7a7b377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0fe6b1b297d9c8e81287d7c7a7b377">&#9670;&nbsp;</a></span>Technique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Technique::Technique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_material.html">Material</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_technique.html">Technique</a> &amp;&#160;</td>
          <td class="paramname"><em>oth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="a3942999affa2e3a81d122ac58f181f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3942999affa2e3a81d122ac58f181f11">&#9670;&nbsp;</a></span>~Technique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::Technique::~Technique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3e262c0765863c31eaaff0cd261b6cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e262c0765863c31eaaff0cd261b6cfa">&#9670;&nbsp;</a></span>isSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isSupported </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates if this technique is supported by the current graphics card. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This will only be correct after the <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has been compiled, which is usually done from <a class="el" href="class_ogre_1_1_material.html#a1f51926064eaa39f9d85393b41bb8870" title="&#39;Compiles&#39; this Material.">Material::compile</a>. </dd></dl>

</div>
</div>
<a id="abec5e34e76944eb89ac0c6d370e3b1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec5e34e76944eb89ac0c6d370e3b1d5">&#9670;&nbsp;</a></span>_compile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> Ogre::Technique::_compile </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoManageTextureUnits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal compilation method; see <a class="el" href="class_ogre_1_1_material.html#a1f51926064eaa39f9d85393b41bb8870" title="&#39;Compiles&#39; this Material.">Material::compile</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> information explaining problems with the compile. </dd></dl>

</div>
</div>
<a id="a2acb60df20fcd4e4ef5d59c83daff3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acb60df20fcd4e4ef5d59c83daff3c0">&#9670;&nbsp;</a></span>checkHardwareSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::checkHardwareSupport </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoManageTextureUnits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af9b3423b7c29049c4cfa637d4a41a28f">StringStream</a> &amp;&#160;</td>
          <td class="paramname"><em>compileErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for checking hardware support. </p>

</div>
</div>
<a id="a9ac14534e5754cae83f2769b4c1ebbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac14534e5754cae83f2769b4c1ebbbd">&#9670;&nbsp;</a></span>calculateSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Technique::calculateSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51466b61bfe2dbcdb1afbf21b1dd3253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51466b61bfe2dbcdb1afbf21b1dd3253">&#9670;&nbsp;</a></span>createPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_pass.html">Pass</a>* Ogre::Technique::createPass </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> for this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> is a single rendering pass, i.e. a single draw of the given material. Note that if you create a pass without a fragment program, during compilation of the material the pass may be split into multiple passes if the graphics card cannot handle the number of texture units requested. For passes with fragment programs, however, the number of passes you create will never be altered, so you have to make sure that you create an alternative fallback <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> for if a card does not have enough facilities for what you're asking for. </dd></dl>

</div>
</div>
<a id="aa8712d608bb9270821c67326369750a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8712d608bb9270821c67326369750a2">&#9670;&nbsp;</a></span>getPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_pass.html">Pass</a>* Ogre::Technique::getPass </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the given index. </p>

</div>
</div>
<a id="a46354c01abc4f183088300551c51b2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46354c01abc4f183088300551c51b2a5">&#9670;&nbsp;</a></span>getPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_pass.html">Pass</a>* Ogre::Technique::getPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> matching name. </p>
<p>Returns 0 if name match is not found. </p>

</div>
</div>
<a id="a5a6bd0bd4989f866dc423f1a78f3ff23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6bd0bd4989f866dc423f1a78f3ff23">&#9670;&nbsp;</a></span>getNumPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::Technique::getNumPasses </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of passes. </p>

</div>
</div>
<a id="af6cff3e7cbf0b677433ca0a0da04c6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cff3e7cbf0b677433ca0a0da04c6aa">&#9670;&nbsp;</a></span>removePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removePass </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the given index. </p>

</div>
</div>
<a id="a1eaae1583cf2e6e310ae911d34da00be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eaae1583cf2e6e310ae911d34da00be">&#9670;&nbsp;</a></span>removeAllPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removeAllPasses </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all Passes from this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>

</div>
</div>
<a id="a6fe998209ba33ea38fdcef68743d678c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe998209ba33ea38fdcef68743d678c">&#9670;&nbsp;</a></span>movePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::movePass </td>
          <td>(</td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>sourceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>destinationIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a pass from source index to destination index. </p>
<p>If successful then returns true. </p>

</div>
</div>
<a id="a84f0ff4e856f6965c7ae8dcab67e6cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f0ff4e856f6965c7ae8dcab67e6cf2">&#9670;&nbsp;</a></span>getPassIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_technique.html#a3b4640d3383f331657fd9ee05cb835c2">PassIterator</a> Ogre::Technique::getPassIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an iterator over the passes in this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000261">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_technique.html#a0eea3c6d9d68dbd7297e478b4e8e487c" title="Gets the passes in this Technique.">getPasses()</a> </dd></dl>

</div>
</div>
<a id="a0eea3c6d9d68dbd7297e478b4e8e487c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eea3c6d9d68dbd7297e478b4e8e487c">&#9670;&nbsp;</a></span>getPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_technique.html#ab6823bce807c243c04e544ee99eea1d1">Passes</a>&amp; Ogre::Technique::getPasses </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the passes in this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>

</div>
</div>
<a id="ac67fd3f320d1541d07cb6c65e58f4892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67fd3f320d1541d07cb6c65e58f4892">&#9670;&nbsp;</a></span>getIlluminationPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___materials.html#gaff4cf78f2520e56a8c45721e2dc419c9">IlluminationPassList</a>&amp; Ogre::Technique::getIlluminationPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the illumination-stage categorised passes. </p>
<dl class="section note"><dt>Note</dt><dd>triggers compilation if needed </dd></dl>

</div>
</div>
<a id="a8143f16e1759f3b5731389d59a66f309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8143f16e1759f3b5731389d59a66f309">&#9670;&nbsp;</a></span>_compileIlluminationPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_compileIlluminationPasses </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for splitting the passes into illumination passes. </p>

</div>
</div>
<a id="a3cff77dca6020ab98c0cbbc225913f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cff77dca6020ab98c0cbbc225913f57">&#9670;&nbsp;</a></span>getParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_material.html">Material</a>* Ogre::Technique::getParent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a>. </p>

</div>
</div>
<a id="ac251efbed20452a6efb1361ea5d27496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac251efbed20452a6efb1361ea5d27496">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_technique.html">Technique</a>&amp; Ogre::Technique::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_technique.html">Technique</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded operator to copy on <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> to another. </p>

</div>
</div>
<a id="a9c7802cd8f4224061fa79d17943c01ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7802cd8f4224061fa79d17943c01ac">&#9670;&nbsp;</a></span>getResourceGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Technique::getResourceGroup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the resource group of the ultimate parent <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a>. </p>

</div>
</div>
<a id="a62b43d297b8de412d601b08978519a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b43d297b8de412d601b08978519a83">&#9670;&nbsp;</a></span>isTransparent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isTransparent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> involves transparency. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This basically boils down to whether the first pass has a scene blending factor. Even if the other passes do not, the base colour, including parts of the original scene, may be used for blending, therefore we have to treat the whole <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> as transparent. </dd></dl>

</div>
</div>
<a id="a100f0393659922c14c06b4cdbf4f2e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100f0393659922c14c06b4cdbf4f2e76">&#9670;&nbsp;</a></span>isTransparentSortingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isTransparentSortingEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has transparent sorting enabled. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This basically boils down to whether the first pass has transparent sorting enabled or not </dd></dl>

</div>
</div>
<a id="a373450226634c5316e9523a006112274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373450226634c5316e9523a006112274">&#9670;&nbsp;</a></span>isTransparentSortingForced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isTransparentSortingForced </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> has transparent sorting forced. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This basically boils down to whether the first pass has transparent sorting forced or not </dd></dl>

</div>
</div>
<a id="a5833abf80056c4a18b6eafb137b590bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5833abf80056c4a18b6eafb137b590bb">&#9670;&nbsp;</a></span>_prepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_prepare </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal prepare method, derived from call to <a class="el" href="class_ogre_1_1_resource.html#a350b287fa3e83a389221274f68760008" title="Prepares the resource for load, if it is not already.">Material::prepare</a>. </p>

</div>
</div>
<a id="ad78f99fe8c81b1dffaf2d9bfc3cfabb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78f99fe8c81b1dffaf2d9bfc3cfabb4">&#9670;&nbsp;</a></span>_unprepare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_unprepare </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal unprepare method, derived from call to Material::unprepare. </p>

</div>
</div>
<a id="a92b98b4f291fa76b02d2adeb822998af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b98b4f291fa76b02d2adeb822998af">&#9670;&nbsp;</a></span>_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_load </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal load method, derived from call to <a class="el" href="class_ogre_1_1_resource.html#a699d1c851f494a8d5d23d23b695ceb47" title="Loads the resource, if it is not already.">Material::load</a>. </p>

</div>
</div>
<a id="a73c19a7dd382f37226f307c3afc98794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c19a7dd382f37226f307c3afc98794">&#9670;&nbsp;</a></span>_unload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_unload </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal unload method, derived from call to <a class="el" href="class_ogre_1_1_resource.html#aa31bef1bfaa87731622e56f11b548e27" title="Unloads the resource; this is not permanent, the resource can be reloaded later if required.">Material::unload</a>. </p>

</div>
</div>
<a id="aaa387fee443de5a25752ec0af27b215d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa387fee443de5a25752ec0af27b215d">&#9670;&nbsp;</a></span>isLoaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isLoaded </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this loaded? </p>

</div>
</div>
<a id="aa5ad18f720bba21676f3424ed7b2382d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ad18f720bba21676f3424ed7b2382d">&#9670;&nbsp;</a></span>_notifyNeedsRecompile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::_notifyNeedsRecompile </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the technique that it needs recompilation. </p>

</div>
</div>
<a id="a46eb3d05e2415ed230c22354ee35773f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46eb3d05e2415ed230c22354ee35773f">&#9670;&nbsp;</a></span>getShadowCasterMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a> Ogre::Technique::getShadowCasterMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return this material specific shadow casting specific material </p>

</div>
</div>
<a id="a93274a8faed940081fed34616fd87412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93274a8faed940081fed34616fd87412">&#9670;&nbsp;</a></span>setShadowCasterMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowCasterMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the details of the material to use when rendering as a shadow caster. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Texture-based shadows require that the caster is rendered to a texture in a solid colour (the shadow colour in the case of modulative texture shadows). Whilst <a class="el" href="namespace_ogre.html">Ogre</a> can arrange this for the fixed function pipeline, passes which use vertex programs might need the vertex programs still to run in order to preserve any deformation etc that it does. However, lighting calculations must be a lot simpler, with only the ambient colour being used (which the engine will ensure is bound to the shadow colour). </dd></dl>
<dl class="section user"><dt></dt><dd>Therefore, it is up to implementors of vertex programs to provide an alternative material which can be used to render the object to a shadow texture. Do all the same vertex transforms, but set the colour of the vertex to the ambient colour, as bound using the standard auto parameter binding mechanism. </dd></dl>

</div>
</div>
<a id="a249a188a0fcafa693e44b9ef3f816261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249a188a0fcafa693e44b9ef3f816261">&#9670;&nbsp;</a></span>setShadowCasterMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowCasterMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set this material specific shadow casting specific material </p>

</div>
</div>
<a id="a72f858e45ae918594cd839fee6a8ea01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f858e45ae918594cd839fee6a8ea01">&#9670;&nbsp;</a></span>getShadowReceiverMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a> Ogre::Technique::getShadowReceiverMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return this material specific shadow receiving specific material </p>

</div>
</div>
<a id="a87d84f017481fd660864627a1952122b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d84f017481fd660864627a1952122b">&#9670;&nbsp;</a></span>setShadowReceiverMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowReceiverMaterial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a57ef769e80226674c3971ce58b58c91d">MaterialPtr</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set this material specific shadow receiving specific material </p>

</div>
</div>
<a id="ac620a86db8a55ac2124b5f599a2a9a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac620a86db8a55ac2124b5f599a2a9a9a">&#9670;&nbsp;</a></span>setShadowReceiverMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadowReceiverMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set this material specific shadow receiving specific material </p>

</div>
</div>
<a id="a1b7d1d264b34c50b7606c646415a50e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7d1d264b34c50b7606c646415a50e8">&#9670;&nbsp;</a></span>setPointSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setPointSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the point size properties for every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a490736f9eaeffd1c60611869d68931ee" title="Sets the point size of this pass.">Pass::setPointSize</a> </dd></dl>

</div>
</div>
<a id="ab4fd76b7e6899ba9f3c302160b392db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fd76b7e6899ba9f3c302160b392db2">&#9670;&nbsp;</a></span>setAmbient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setAmbient </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the ambient colour reflectance properties for every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in every <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#aba057d0d19159c21b9a79485512b6f9d" title="Sets the ambient colour reflectance properties of this pass.">Pass::setAmbient</a> </dd></dl>

</div>
</div>
<a id="ac5d459624ede01672c78846825cc0f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d459624ede01672c78846825cc0f96">&#9670;&nbsp;</a></span>setAmbient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setAmbient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>ambient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a290b26bac425c362ad25278ff19117bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290b26bac425c362ad25278ff19117bf">&#9670;&nbsp;</a></span>setDiffuse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDiffuse </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the diffuse colour reflectance properties of every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in every <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a823dd0856cf4d8bfa08abc3591c47c02" title="Sets the diffuse colour reflectance properties of this pass.">Pass::setDiffuse</a> </dd></dl>

</div>
</div>
<a id="af5e13d58c70bbeeb1708e1479185a959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e13d58c70bbeeb1708e1479185a959">&#9670;&nbsp;</a></span>setDiffuse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDiffuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>diffuse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a8a9302152c679910610981ba42cae926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9302152c679910610981ba42cae926">&#9670;&nbsp;</a></span>setSpecular() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSpecular </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specular colour reflectance properties of every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in every <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a4e47ea4922d6da5b58eb9879f7e9da09" title="Sets the specular colour reflectance properties of this pass.">Pass::setSpecular</a> </dd></dl>

</div>
</div>
<a id="a0add9d092f47eb2b654d936a66902d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0add9d092f47eb2b654d936a66902d00">&#9670;&nbsp;</a></span>setSpecular() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSpecular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>specular</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aed27a55db91366ee2f95a608f946bc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed27a55db91366ee2f95a608f946bc86">&#9670;&nbsp;</a></span>setShininess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShininess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the shininess properties of every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in every <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#af0977cabd2a7fb79f9ee03078f79011a" title="Sets the shininess of the pass, affecting the size of specular highlights.">Pass::setShininess</a> </dd></dl>

</div>
</div>
<a id="aff783d9452b6787a0fdbf83fd8ea0b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff783d9452b6787a0fdbf83fd8ea0b33">&#9670;&nbsp;</a></span>setSelfIllumination() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSelfIllumination </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the amount of self-illumination of every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> in every <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a93c36ae948d9e0357c11adb0ce6d5859" title="Sets the amount of self-illumination an object has.">Pass::setSelfIllumination</a> </dd></dl>

</div>
</div>
<a id="a9e5d7120bf501c5796bb461ec16ca22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5d7120bf501c5796bb461ec16ca22d">&#9670;&nbsp;</a></span>setSelfIllumination() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSelfIllumination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>selfIllum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a8ccefe2b6bb5b6e66e2dcb081f92847f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccefe2b6bb5b6e66e2dcb081f92847f">&#9670;&nbsp;</a></span>setDepthCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not each <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> renders with depth-buffer checking on or not. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not.">Pass::setDepthCheckEnabled</a> </dd></dl>

</div>
</div>
<a id="a17ab42d4b777c0782a2d0170ae5a0970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ab42d4b777c0782a2d0170ae5a0970">&#9670;&nbsp;</a></span>setDepthWriteEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not each <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> renders with depth-buffer writing on or not. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#aad3e6c7c7b59e2c303c348b4850b1a3a" title="Sets whether or not this pass renders with depth-buffer writing on or not.">Pass::setDepthWriteEnabled</a> </dd></dl>

</div>
</div>
<a id="a1f8f52bd7bc067a8f6dac99757063a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8f52bd7bc067a8f6dac99757063a06">&#9670;&nbsp;</a></span>setDepthFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga8e1c2888df9ea68a8fa31b64b6aa67d6">CompareFunction</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the function used to compare depth values when depth checking is on. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#aef6c591b069aa6f7c65afc1419d47de6" title="Sets the function used to compare depth values when depth checking is on.">Pass::setDepthFunction</a> </dd></dl>

</div>
</div>
<a id="a155d2bb172e767eab0880667b8669057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155d2bb172e767eab0880667b8669057">&#9670;&nbsp;</a></span>setColourWriteEnabled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setColourWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not colour buffer writing is enabled for each <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a3bbe37daba7e3be4349177374d4e40ee" title="Sets whether or not colour buffer writing is enabled for this Pass.">Pass::setColourWriteEnabled</a> </dd></dl>

</div>
</div>
<a id="a28dabe8ffdef677134ba9514bf3c2895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dabe8ffdef677134ba9514bf3c2895">&#9670;&nbsp;</a></span>setColourWriteEnabled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setColourWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>red</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>green</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets which colour buffer channels are enabled for writing for each <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a3bbe37daba7e3be4349177374d4e40ee" title="Sets whether or not colour buffer writing is enabled for this Pass.">Pass::setColourWriteEnabled</a> </dd></dl>

</div>
</div>
<a id="ae3ab7639e71d6118834a9164a7c1c8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ab7639e71d6118834a9164a7c1c8f9">&#9670;&nbsp;</a></span>setCullingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setCullingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga4766f4c65e0a47f0a71c5908944a7a3c">CullingMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the culling mode for each pass based on the 'vertex winding'. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a8942abf3ede0f3cb43584c85c4071734" title="Sets the culling mode for this pass based on the &#39;vertex winding&#39;.">Pass::setCullingMode</a> </dd></dl>

</div>
</div>
<a id="a9d9340f9b31f6189e28d62ab00937ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9340f9b31f6189e28d62ab00937ab0">&#9670;&nbsp;</a></span>setManualCullingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setManualCullingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga67144aea217e56725c43541fb064af20">ManualCullingMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the manual culling mode, performed by CPU rather than hardware. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a3b528827b54f17b72bb204321640a6f7" title="Sets the manual culling mode, performed by CPU rather than hardware.">Pass::setManualCullingMode</a> </dd></dl>

</div>
</div>
<a id="ab6f31b910ad3b0a22219210290622482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f31b910ad3b0a22219210290622482">&#9670;&nbsp;</a></span>setLightingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setLightingEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not dynamic lighting is enabled for every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a6285f13a06eb7f00b83ea2754e434623" title="Sets whether or not dynamic lighting is enabled.">Pass::setLightingEnabled</a> </dd></dl>

</div>
</div>
<a id="a4c3bb63365c701842d4539e32cc1480e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3bb63365c701842d4539e32cc1480e">&#9670;&nbsp;</a></span>setShadingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setShadingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga12cb29cae690b696c0f1c4863d8c25a7">ShadeOptions</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the type of light shading required. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#ade6c00297cd5d46bb365d981cd1764a6" title="Sets the type of light shading required.">Pass::setShadingMode</a> </dd></dl>

</div>
</div>
<a id="a341545383916252e51c508139903574a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341545383916252e51c508139903574a">&#9670;&nbsp;</a></span>setFog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setFog </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overrideScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___general.html#ga6467b107ce81cc71b8f2960409f7d897">FogMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="group___general.html#gga6467b107ce81cc71b8f2960409f7d897ab7793a21880052c0214d4cc040992310">FOG_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>colour</em> = <code><a class="el" href="class_ogre_1_1_colour_value.html#a8eba66b2908f44f00f8d9c9ec25877de">ColourValue::White</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>expDensity</em> = <code>0.001f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>linearStart</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>linearEnd</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fogging mode applied to each pass. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#a48a2a5f63407356c4e080cbea73b651b" title="Sets the fogging mode applied to this pass.">Pass::setFog</a> </dd></dl>

</div>
</div>
<a id="a58b4e86384ca3e7a9f03c3fb2a5b3f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b4e86384ca3e7a9f03c3fb2a5b3f0d">&#9670;&nbsp;</a></span>setDepthBias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setDepthBias </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>constantBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>slopeScaleBias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the depth bias to be used for each <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#aa35a3242a45176f8605bd8c866198b67" title="Sets the depth bias to be used for this material.">Pass::setDepthBias</a> </dd></dl>

</div>
</div>
<a id="a67d7464ef321b859c33c3c1e9334c5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d7464ef321b859c33c3c1e9334c5f2">&#9670;&nbsp;</a></span>setTextureFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setTextureFiltering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5">TextureFilterOptions</a>&#160;</td>
          <td class="paramname"><em>filterType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set texture filtering for every texture unit in every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> class For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the <br  />
 <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> and <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> instances and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_unit_state.html#a30757c168b734902d03720e3f36c27d4" title="Set the texture filtering for this unit, using the simplified interface.">TextureUnitState::setTextureFiltering</a> </dd></dl>

</div>
</div>
<a id="a60e62cb6b00f8ae9e9da077d0ecc08ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e62cb6b00f8ae9e9da077d0ecc08ec">&#9670;&nbsp;</a></span>setTextureAnisotropy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setTextureAnisotropy </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxAniso</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the anisotropy level to be used for all textures. </p>
<dl class="section note"><dt>Note</dt><dd>This property has been moved to the <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> class, which is accessible via the <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> and <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a>. For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>, <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> and <a class="el" href="class_ogre_1_1_texture_unit_state.html" title="Class representing the state of a single texture unit during a Pass of a Technique,...">TextureUnitState</a> instances and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_texture_unit_state.html#abb2bc03bc72f2098e37c4240f637c5e5" title="Sets the anisotropy level to be used for this texture level.">TextureUnitState::setTextureAnisotropy</a> </dd></dl>

</div>
</div>
<a id="a8d44a97049862fc9c5eb64caf5cbbc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d44a97049862fc9c5eb64caf5cbbc2f">&#9670;&nbsp;</a></span>setSceneBlending() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&#160;</td>
          <td class="paramname"><em>sbt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the kind of blending every pass has with the existing contents of the scene. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#ae21d6f29c89eeff54ab6de5562818c02" title="Sets the kind of blending this pass has with the existing contents of the scene.">Pass::setSceneBlending</a> </dd></dl>

</div>
</div>
<a id="add4cd758dc843921da3a331bcc1bee1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4cd758dc843921da3a331bcc1bee1d">&#9670;&nbsp;</a></span>setSeparateSceneBlending() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSeparateSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&#160;</td>
          <td class="paramname"><em>sbt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___materials.html#gac46c60cf6e5c199220e3b8f26570cb9a">SceneBlendType</a>&#160;</td>
          <td class="paramname"><em>sbta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the kind of blending every pass has with the existing contents of the scene, using individual factors both color and alpha channels. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#aefbd80d762d78838df626482df1ac81b" title="Sets the kind of blending this pass has with the existing contents of the scene, separately for color...">Pass::setSeparateSceneBlending</a> </dd></dl>

</div>
</div>
<a id="a50815d7c51c153e2a6ab1b581507d28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50815d7c51c153e2a6ab1b581507d28f">&#9670;&nbsp;</a></span>setSceneBlending() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>destFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows very fine control of blending every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the existing contents of the scene. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#ae21d6f29c89eeff54ab6de5562818c02" title="Sets the kind of blending this pass has with the existing contents of the scene.">Pass::setSceneBlending</a> </dd></dl>

</div>
</div>
<a id="a5df9ffbf40cbce69799b3be95cf4b701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df9ffbf40cbce69799b3be95cf4b701">&#9670;&nbsp;</a></span>setSeparateSceneBlending() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSeparateSceneBlending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>sourceFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>destFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>sourceFactorAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___materials.html#ga41c76d419d6c9c205a6c1d3b42872213">SceneBlendFactor</a>&#160;</td>
          <td class="paramname"><em>destFactorAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows very fine control of blending every <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> with the existing contents of the scene, using individual factors both color and alpha channels. </p>
<dl class="section note"><dt>Note</dt><dd>This property actually exists on the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> class. For simplicity, this method allows you to set these properties for every current <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> within this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. If you need more precision, retrieve the <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material): a single rendering call.">Pass</a> instance and set the property there. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_pass.html#aefbd80d762d78838df626482df1ac81b" title="Sets the kind of blending this pass has with the existing contents of the scene, separately for color...">Pass::setSeparateSceneBlending</a> </dd></dl>

</div>
</div>
<a id="ab72db7823cc9a8e872aed1ca6ae2cff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72db7823cc9a8e872aed1ca6ae2cff8">&#9670;&nbsp;</a></span>setLodIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setLodIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a level-of-detail (LOD) index to this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>As noted previously, as well as providing fallback support for various graphics cards, multiple <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> objects can also be used to implement material LOD, where the detail of the material diminishes with distance to save rendering power. </dd></dl>
<dl class="section user"><dt></dt><dd>By default, all Techniques have a LOD index of 0, which means they are the highest level of detail. Increasing LOD indexes are lower levels of detail. You can assign more than one <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> to the same LOD index, meaning that the best <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> that is supported at that LOD index is used. </dd></dl>
<dl class="section user"><dt></dt><dd>You should not leave gaps in the LOD sequence; <a class="el" href="namespace_ogre.html">Ogre</a> will allow you to do this and will continue to function as if the LODs were sequential, but it will confuse matters. </dd></dl>

</div>
</div>
<a id="a18697c9c5f2bc1f98d3789ca26a6c0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18697c9c5f2bc1f98d3789ca26a6c0ec">&#9670;&nbsp;</a></span>getLodIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Technique::getLodIndex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the level-of-detail index assigned to this <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>. </p>

</div>
</div>
<a id="a43b6c4e9e48c4e56f96633b916ee90a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b6c4e9e48c4e56f96633b916ee90a3">&#9670;&nbsp;</a></span>setSchemeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setSchemeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the 'scheme name' for this technique. </p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object.">Material</a> schemes are used to control top-level switching from one set of techniques to another. For example, you might use this to define 'high', 'medium' and 'low' complexity levels on materials to allow a user to pick a performance / quality ratio. Another possibility is that you have a fully HDR-enabled pipeline for top machines, rendering all objects using unclamped shaders, and a simpler pipeline for others; this can be implemented using schemes. </dd></dl>
<dl class="section user"><dt></dt><dd>Every technique belongs to a scheme - if you don't specify one, the <a class="el" href="class_ogre_1_1_technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> belongs to the scheme called 'Default', which is also the scheme used to render by default. The active scheme is set one of two ways - either by calling <a class="el" href="class_ogre_1_1_viewport.html#a8e8577fd81c45b05de880106f364a281" title="Set the material scheme which the viewport should use.">Viewport::setMaterialScheme</a>, or by manually calling <a class="el" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0" title="Sets the name of the active material scheme.">MaterialManager::setActiveScheme</a>. </dd></dl>

</div>
</div>
<a id="a5472361e875965fa57fa7576f832cc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5472361e875965fa57fa7576f832cc7d">&#9670;&nbsp;</a></span>getSchemeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Technique::getSchemeName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the scheme to which this technique is assigned. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_technique.html#a43b6c4e9e48c4e56f96633b916ee90a3" title="Set the &#39;scheme name&#39; for this technique.">Technique::setSchemeName</a> </dd></dl>

</div>
</div>
<a id="a8d374e0051b5d0a38ff9232369720a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d374e0051b5d0a38ff9232369720a7b">&#9670;&nbsp;</a></span>_getSchemeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short Ogre::Technique::_getSchemeIndex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for getting the scheme index. </p>

</div>
</div>
<a id="a93ca213f1f6b4e5de440950f87d16c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ca213f1f6b4e5de440950f87d16c82">&#9670;&nbsp;</a></span>isDepthWriteEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isDepthWriteEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is depth writing going to occur on this technique? </p>

</div>
</div>
<a id="a5b1efc3fe1d8143d2f5d5d65127c2e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1efc3fe1d8143d2f5d5d65127c2e27">&#9670;&nbsp;</a></span>isDepthCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::isDepthCheckEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is depth checking going to occur on this technique? </p>

</div>
</div>
<a id="aeaf1f068b46e9249c6ba4621ef695256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf1f068b46e9249c6ba4621ef695256">&#9670;&nbsp;</a></span>hasColourWriteDisabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::hasColourWriteDisabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exists colour writing disabled pass on this technique? </p>

</div>
</div>
<a id="a365b0e6313b646d0ecc13c1c52a6d3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365b0e6313b646d0ecc13c1c52a6d3ad">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::setName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the name of the technique. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The use of technique name is optional. Its useful in material scripts where a material could inherit from another material and only want to modify a particular technique. </dd></dl>

</div>
</div>
<a id="a7751c3441cb6cbc1744f29c4ccb63ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7751c3441cb6cbc1744f29c4ccb63ef0">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::Technique::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the name of the technique. </p>

</div>
</div>
<a id="a67154e6706213a946623bef7f2b65450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67154e6706213a946623bef7f2b65450">&#9670;&nbsp;</a></span>checkGPURules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::Technique::checkGPURules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af9b3423b7c29049c4cfa637d4a41a28f">StringStream</a> &amp;&#160;</td>
          <td class="paramname"><em>errors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for checking GPU vendor / device rules. </p>

</div>
</div>
<a id="afe3b09baa8cd8566f994ad4ee5d125d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3b09baa8cd8566f994ad4ee5d125d1">&#9670;&nbsp;</a></span>addGPUVendorRule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUVendorRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___render_system.html#gac4c251bcc05376f701348bfe0f4a53b4">GPUVendor</a>&#160;</td>
          <td class="paramname"><em>vendor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a>&#160;</td>
          <td class="paramname"><em>includeOrExclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a rule which manually influences the support for this technique based on a GPU vendor. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You can use this facility to manually control whether a technique is considered supported, based on a GPU vendor. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> rule for the same vendor will be removed before adding this one. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vendor</td><td>The GPU vendor </td></tr>
    <tr><td class="paramname">includeOrExclude</td><td>Whether this is an inclusive or exclusive rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6a82a8dedd6ecc9228e392aec08bd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a82a8dedd6ecc9228e392aec08bd52">&#9670;&nbsp;</a></span>addGPUVendorRule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUVendorRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_technique_1_1_g_p_u_vendor_rule.html">GPUVendorRule</a> &amp;&#160;</td>
          <td class="paramname"><em>rule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a rule which manually influences the support for this technique based on a GPU vendor. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You can use this facility to manually control whether a technique is considered supported, based on a GPU vendor. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> rule for the same vendor will be removed before adding this one. </dd></dl>

</div>
</div>
<a id="aeaadeb93509d6fc3ca27686ca83e76be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaadeb93509d6fc3ca27686ca83e76be">&#9670;&nbsp;</a></span>removeGPUVendorRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removeGPUVendorRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___render_system.html#gac4c251bcc05376f701348bfe0f4a53b4">GPUVendor</a>&#160;</td>
          <td class="paramname"><em>vendor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a matching vendor rule. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_technique.html#afe3b09baa8cd8566f994ad4ee5d125d1" title="Add a rule which manually influences the support for this technique based on a GPU vendor.">addGPUVendorRule</a> </dd></dl>

</div>
</div>
<a id="a87bae44184a980abc5c1fad546781c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bae44184a980abc5c1fad546781c22">&#9670;&nbsp;</a></span>getGPUVendorRuleIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_technique.html#a2497a0043902e9d2af0757d769da655c">GPUVendorRuleIterator</a> Ogre::Technique::getGPUVendorRuleIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000262">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_technique.html#a5f207095e9bbda9dde11227756c1e8e8" title="Get the currently registered vendor rules.">getGPUVendorRules()</a> </dd></dl>

</div>
</div>
<a id="a5f207095e9bbda9dde11227756c1e8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f207095e9bbda9dde11227756c1e8e8">&#9670;&nbsp;</a></span>getGPUVendorRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_technique.html#a02400e8fcd433054c6559331858a782e">GPUVendorRuleList</a>&amp; Ogre::Technique::getGPUVendorRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently registered vendor rules. </p>

</div>
</div>
<a id="ab6be978dbdbe321f7e8e9803aa29c2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6be978dbdbe321f7e8e9803aa29c2d1">&#9670;&nbsp;</a></span>addGPUDeviceNameRule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUDeviceNameRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>devicePattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_technique.html#a1ade219e17b5e8d73d079d11f64a2a2d">IncludeOrExclude</a>&#160;</td>
          <td class="paramname"><em>includeOrExclude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>caseSensitive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g. </p>
<p>'<em>8800</em>'). </p><dl class="section remark"><dt>Remarks</dt><dd>You can use this facility to manually control whether a technique is considered supported, based on a GPU device name pattern. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. The pattern you supply can include wildcard characters ('*') if you only want to match part of the device name. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_ogre_1_1_any.html" title="Variant type that can hold Any other type.">Any</a> rule for the same device pattern will be removed before adding this one. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devicePattern</td><td>The GPU vendor </td></tr>
    <tr><td class="paramname">includeOrExclude</td><td>Whether this is an inclusive or exclusive rule </td></tr>
    <tr><td class="paramname">caseSensitive</td><td>Whether the match is case sensitive or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0b1efd013753818ae29fd15a27c9744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b1efd013753818ae29fd15a27c9744">&#9670;&nbsp;</a></span>addGPUDeviceNameRule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::addGPUDeviceNameRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_ogre_1_1_technique_1_1_g_p_u_device_name_rule.html">GPUDeviceNameRule</a> &amp;&#160;</td>
          <td class="paramname"><em>rule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a593e0e3c8e9d7a43155be8c6fdbfa8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593e0e3c8e9d7a43155be8c6fdbfa8f7">&#9670;&nbsp;</a></span>removeGPUDeviceNameRule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::Technique::removeGPUDeviceNameRule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>devicePattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a matching device name rule. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_technique.html#ab6be978dbdbe321f7e8e9803aa29c2d1" title="Add a rule which manually influences the support for this technique based on a pattern that matches a...">addGPUDeviceNameRule</a> </dd></dl>

</div>
</div>
<a id="a8220d069967117f15e63a236e221c6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8220d069967117f15e63a236e221c6a2">&#9670;&nbsp;</a></span>getGPUDeviceNameRuleIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_technique.html#a63da4eb10f7272486a9806374b09bab6">GPUDeviceNameRuleIterator</a> Ogre::Technique::getGPUDeviceNameRuleIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000263">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_technique.html#a0fb4cc2bde522445d8d4548e6c6697d4" title="Get the currently registered device name rules.">getGPUDeviceNameRules()</a> </dd></dl>

</div>
</div>
<a id="a0fb4cc2bde522445d8d4548e6c6697d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb4cc2bde522445d8d4548e6c6697d4">&#9670;&nbsp;</a></span>getGPUDeviceNameRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_technique.html#a19e4233dcb87fbb8d592133ca7f10626">GPUDeviceNameRuleList</a>&amp; Ogre::Technique::getGPUDeviceNameRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the currently registered device name rules. </p>

</div>
</div>
<a id="a96db53bdf6b3f097fcb9a038df84abe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96db53bdf6b3f097fcb9a038df84abe9">&#9670;&nbsp;</a></span>getUserObjectBindings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Technique::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance.">UserObjectBindings::setUserAny</a>. </dd></dl>

</div>
</div>
<a id="a9fd23883c7d06966a259a1490a6b8ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd23883c7d06966a259a1490a6b8ffa">&#9670;&nbsp;</a></span>getUserObjectBindings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::Technique::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance.">UserObjectBindings::setUserAny</a>. <br  />
 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_technique_8h.html">OgreTechnique.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_technique.html">Technique</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
