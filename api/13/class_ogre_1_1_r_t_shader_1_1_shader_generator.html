<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Ogre::RTShader::ShaderGenerator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.2</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ogre_1_1_r_t_shader_1_1_shader_generator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_ogre_1_1_r_t_shader_1_1_shader_generator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::RTShader::ShaderGenerator Class Reference<div class="ingroups"><a class="el" href="group___optional.html">Optional Components</a> &raquo; <a class="el" href="group___r_t_shader.html">RTShaderSystem</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Shader generator system main interface.  
 <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#details">More...</a></p>

<p><code>#include &lt;OgreShaderGenerator.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::RTShader::ShaderGenerator:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_r_t_shader_1_1_shader_generator__inherit__graph.svg" width="464" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac7eb87c69e1a22e1ad0c0c4a3a9dded1"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">RenderState</a> *, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac7eb87c69e1a22e1ad0c0c4a3a9dded1">RenderStateCreateOrRetrieveResult</a></td></tr>
<tr class="separator:ac7eb87c69e1a22e1ad0c0c4a3a9dded1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4724bbbba4c2e18a7306f98cdfa8ffe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a4724bbbba4c2e18a7306f98cdfa8ffe1">_setActiveSceneManager</a> (<a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneManager)</td></tr>
<tr class="memdesc:a4724bbbba4c2e18a7306f98cdfa8ffe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the active scene manager against which new render states are compiled.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a4724bbbba4c2e18a7306f98cdfa8ffe1">More...</a><br /></td></tr>
<tr class="separator:a4724bbbba4c2e18a7306f98cdfa8ffe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60704776c069e2a6bd37692f88c56815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a60704776c069e2a6bd37692f88c56815">addSceneManager</a> (<a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneMgr)</td></tr>
<tr class="memdesc:a60704776c069e2a6bd37692f88c56815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a scene manager to the shader generator scene managers list.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a60704776c069e2a6bd37692f88c56815">More...</a><br /></td></tr>
<tr class="separator:a60704776c069e2a6bd37692f88c56815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac266946244d79b2d4732607ae9479bd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9">addSubRenderStateFactory</a> (<a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html">SubRenderStateFactory</a> *factory)</td></tr>
<tr class="memdesc:ac266946244d79b2d4732607ae9479bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add sub render state factory.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9">More...</a><br /></td></tr>
<tr class="separator:ac266946244d79b2d4732607ae9479bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f9e8965650ed9c2fc35e72ae2aa1e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a54f9e8965650ed9c2fc35e72ae2aa1e3">cloneShaderBasedTechniques</a> (const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;srcMat, <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;dstMat)</td></tr>
<tr class="memdesc:a54f9e8965650ed9c2fc35e72ae2aa1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone all shader based techniques from one material to another.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a54f9e8965650ed9c2fc35e72ae2aa1e3">More...</a><br /></td></tr>
<tr class="separator:a54f9e8965650ed9c2fc35e72ae2aa1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db5e39bdc0c411e5052b99f1655f75e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac7eb87c69e1a22e1ad0c0c4a3a9dded1">RenderStateCreateOrRetrieveResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a7db5e39bdc0c411e5052b99f1655f75e">createOrRetrieveRenderState</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName)</td></tr>
<tr class="memdesc:a7db5e39bdc0c411e5052b99f1655f75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a requested render state.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a7db5e39bdc0c411e5052b99f1655f75e">More...</a><br /></td></tr>
<tr class="separator:a7db5e39bdc0c411e5052b99f1655f75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d27197d6de2e7b02bf0127cc9619081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a4d27197d6de2e7b02bf0127cc9619081">createScheme</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName)</td></tr>
<tr class="memdesc:a4d27197d6de2e7b02bf0127cc9619081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scheme.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a4d27197d6de2e7b02bf0127cc9619081">More...</a><br /></td></tr>
<tr class="separator:a4d27197d6de2e7b02bf0127cc9619081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02d3e93da75e66ed3312b5790d18868"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868">createShaderBasedTechnique</a> (const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;srcMat, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;srcTechniqueSchemeName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;dstTechniqueSchemeName, bool overProgrammable=false)</td></tr>
<tr class="memdesc:af02d3e93da75e66ed3312b5790d18868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create shader based technique from a given technique.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868">More...</a><br /></td></tr>
<tr class="separator:af02d3e93da75e66ed3312b5790d18868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701b44491228077d3e2aca6a49f94499"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a701b44491228077d3e2aca6a49f94499">createShaderBasedTechnique</a> (const <a class="el" href="class_ogre_1_1_technique.html">Technique</a> *srcTech, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;dstTechniqueSchemeName, bool overProgrammable=false)</td></tr>
<tr class="memdesc:a701b44491228077d3e2aca6a49f94499"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a701b44491228077d3e2aca6a49f94499">More...</a><br /></td></tr>
<tr class="separator:a701b44491228077d3e2aca6a49f94499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512dbd23cc30a2dd2c5c344d1faac0d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a512dbd23cc30a2dd2c5c344d1faac0d2"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a512dbd23cc30a2dd2c5c344d1faac0d2">createSubRenderState</a> ()</td></tr>
<tr class="memdesc:a512dbd23cc30a2dd2c5c344d1faac0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a512dbd23cc30a2dd2c5c344d1faac0d2">More...</a><br /></td></tr>
<tr class="separator:a512dbd23cc30a2dd2c5c344d1faac0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fe4ab6a8fb0e1b2ba67e2506b1e992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">SubRenderState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad4fe4ab6a8fb0e1b2ba67e2506b1e992">createSubRenderState</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;type)</td></tr>
<tr class="memdesc:ad4fe4ab6a8fb0e1b2ba67e2506b1e992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an instance of sub render state from a given type.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad4fe4ab6a8fb0e1b2ba67e2506b1e992">More...</a><br /></td></tr>
<tr class="separator:ad4fe4ab6a8fb0e1b2ba67e2506b1e992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a2d06db88797395cf55f6d84595205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a59a2d06db88797395cf55f6d84595205">destroySubRenderState</a> (<a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">SubRenderState</a> *subRenderState)</td></tr>
<tr class="memdesc:a59a2d06db88797395cf55f6d84595205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an instance of sub render state.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a59a2d06db88797395cf55f6d84595205">More...</a><br /></td></tr>
<tr class="separator:a59a2d06db88797395cf55f6d84595205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6479b03aee3ab7160187ecfc86604a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a2f6479b03aee3ab7160187ecfc86604a">flushShaderCache</a> ()</td></tr>
<tr class="memdesc:a2f6479b03aee3ab7160187ecfc86604a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the shader cache.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a2f6479b03aee3ab7160187ecfc86604a">More...</a><br /></td></tr>
<tr class="separator:a2f6479b03aee3ab7160187ecfc86604a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8adc0f4b3a70aed7eecb2b88d399588"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad8adc0f4b3a70aed7eecb2b88d399588">getActiveSceneManager</a> ()</td></tr>
<tr class="memdesc:ad8adc0f4b3a70aed7eecb2b88d399588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active scene manager that is doint the actual scene rendering.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad8adc0f4b3a70aed7eecb2b88d399588">More...</a><br /></td></tr>
<tr class="separator:ad8adc0f4b3a70aed7eecb2b88d399588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de4a29532eeca2dd8f8a44e78c05e3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a6de4a29532eeca2dd8f8a44e78c05e3a">getCreateShaderOverProgrammablePass</a> () const</td></tr>
<tr class="memdesc:a6de4a29532eeca2dd8f8a44e78c05e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether shaders are created for passes with shaders.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a6de4a29532eeca2dd8f8a44e78c05e3a">More...</a><br /></td></tr>
<tr class="separator:a6de4a29532eeca2dd8f8a44e78c05e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416c5013cc01c0f9b64ca98a50a202f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_material_serializer_1_1_listener.html">MaterialSerializer::Listener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a416c5013cc01c0f9b64ca98a50a202f4">getMaterialSerializerListener</a> ()</td></tr>
<tr class="memdesc:a416c5013cc01c0f9b64ca98a50a202f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return custom material <a class="el" href="class_ogre_1_1_serializer.html" title="Generic class for serialising data to / from binary stream-based files.">Serializer</a> of the shader generator.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a416c5013cc01c0f9b64ca98a50a202f4">More...</a><br /></td></tr>
<tr class="separator:a416c5013cc01c0f9b64ca98a50a202f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fee1229b6cd03d9da70e58e3290848"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a96fee1229b6cd03d9da70e58e3290848">getNumSubRenderStateFactories</a> () const</td></tr>
<tr class="memdesc:a96fee1229b6cd03d9da70e58e3290848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of existing factories.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a96fee1229b6cd03d9da70e58e3290848">More...</a><br /></td></tr>
<tr class="separator:a96fee1229b6cd03d9da70e58e3290848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7167dbc5b45f11cae4a5dc61c0a823"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">RenderState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a3d7167dbc5b45f11cae4a5dc61c0a823">getRenderState</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName)</td></tr>
<tr class="memdesc:a3d7167dbc5b45f11cae4a5dc61c0a823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a global render state associated with the given scheme name.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a3d7167dbc5b45f11cae4a5dc61c0a823">More...</a><br /></td></tr>
<tr class="separator:a3d7167dbc5b45f11cae4a5dc61c0a823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a62e6db3899eed370e00d96170a74b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">RenderState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac3a62e6db3899eed370e00d96170a74b">getRenderState</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName, const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;mat, <a class="el" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a> passIndex=0)</td></tr>
<tr class="memdesc:ac3a62e6db3899eed370e00d96170a74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac3a62e6db3899eed370e00d96170a74b">More...</a><br /></td></tr>
<tr class="separator:ac3a62e6db3899eed370e00d96170a74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c475bb3a78d796d1f28407b3a476712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">RenderState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a1c475bb3a78d796d1f28407b3a476712">getRenderState</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;materialName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;groupName, unsigned short passIndex)</td></tr>
<tr class="memdesc:a1c475bb3a78d796d1f28407b3a476712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get render state of specific pass.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a1c475bb3a78d796d1f28407b3a476712">More...</a><br /></td></tr>
<tr class="separator:a1c475bb3a78d796d1f28407b3a476712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a32eb5519fa040eced4a6c94025dbd8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a8a32eb5519fa040eced4a6c94025dbd8">getRTShaderScheme</a> (size_t index) const</td></tr>
<tr class="memdesc:a8a32eb5519fa040eced4a6c94025dbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scheme name used in the for RT shader generation by index.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a8a32eb5519fa040eced4a6c94025dbd8">More...</a><br /></td></tr>
<tr class="separator:a8a32eb5519fa040eced4a6c94025dbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff76240698adc0202e64be7055613015"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#aff76240698adc0202e64be7055613015">getRTShaderSchemeCount</a> () const</td></tr>
<tr class="memdesc:aff76240698adc0202e64be7055613015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of schemes used in the for RT shader generation.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#aff76240698adc0202e64be7055613015">More...</a><br /></td></tr>
<tr class="separator:aff76240698adc0202e64be7055613015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0a1b86511924d42a007d092af0900c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a0f0a1b86511924d42a007d092af0900c">getShaderCachePath</a> () const</td></tr>
<tr class="memdesc:a0f0a1b86511924d42a007d092af0900c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output shader cache path.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a0f0a1b86511924d42a007d092af0900c">More...</a><br /></td></tr>
<tr class="separator:a0f0a1b86511924d42a007d092af0900c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c45f520b80e490a398b5d3c625463a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af5c45f520b80e490a398b5d3c625463a">getShaderCount</a> (<a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a> type) const</td></tr>
<tr class="memdesc:af5c45f520b80e490a398b5d3c625463a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current number of generated shaders.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af5c45f520b80e490a398b5d3c625463a">More...</a><br /></td></tr>
<tr class="separator:af5c45f520b80e490a398b5d3c625463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dc9c750980554a61a18ec1f983fae2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a61dc9c750980554a61a18ec1f983fae2">getShaderProfiles</a> (<a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a> type) const</td></tr>
<tr class="memdesc:a61dc9c750980554a61a18ec1f983fae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output shader target profiles.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a61dc9c750980554a61a18ec1f983fae2">More...</a><br /></td></tr>
<tr class="separator:a61dc9c750980554a61a18ec1f983fae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60196108386f7ca4a82a56eff383242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html">SubRenderStateFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#aa60196108386f7ca4a82a56eff383242">getSubRenderStateFactory</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;type)</td></tr>
<tr class="memdesc:aa60196108386f7ca4a82a56eff383242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub render state factory by name.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#aa60196108386f7ca4a82a56eff383242">More...</a><br /></td></tr>
<tr class="separator:aa60196108386f7ca4a82a56eff383242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d439aa0c31457ae0341e55f97e08219"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html">SubRenderStateFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a1d439aa0c31457ae0341e55f97e08219">getSubRenderStateFactory</a> (size_t index)</td></tr>
<tr class="memdesc:a1d439aa0c31457ae0341e55f97e08219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a sub render state factory by index.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a1d439aa0c31457ae0341e55f97e08219">More...</a><br /></td></tr>
<tr class="separator:a1d439aa0c31457ae0341e55f97e08219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0c4cd10d66291d77f43267d52b73e3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a7a0c4cd10d66291d77f43267d52b73e3">getTargetLanguage</a> () const</td></tr>
<tr class="memdesc:a7a0c4cd10d66291d77f43267d52b73e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the target shader language currently in use.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a7a0c4cd10d66291d77f43267d52b73e3">More...</a><br /></td></tr>
<tr class="separator:a7a0c4cd10d66291d77f43267d52b73e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f0f0f8724ac9d60e76409cdd3ec01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre_1_1_r_t_shader.html#ab0694782a83ac342574ac3cf1e053355">VSOutputCompactPolicy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a6e4f0f0f8724ac9d60e76409cdd3ec01">getVertexShaderOutputsCompactPolicy</a> () const</td></tr>
<tr class="memdesc:a6e4f0f0f8724ac9d60e76409cdd3ec01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vertex shader outputs compaction policy.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a6e4f0f0f8724ac9d60e76409cdd3ec01">More...</a><br /></td></tr>
<tr class="separator:a6e4f0f0f8724ac9d60e76409cdd3ec01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51041e1b67f991880265f8c92081a984"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a51041e1b67f991880265f8c92081a984">hasRenderState</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName) const</td></tr>
<tr class="memdesc:a51041e1b67f991880265f8c92081a984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if a given render state exists.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a51041e1b67f991880265f8c92081a984">More...</a><br /></td></tr>
<tr class="separator:a51041e1b67f991880265f8c92081a984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbce5e71d7e419f3f6eae836375623d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a2cbce5e71d7e419f3f6eae836375623d">hasShaderBasedTechnique</a> (const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;mat, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;srcTechniqueSchemeName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;dstTechniqueSchemeName) const</td></tr>
<tr class="memdesc:a2cbce5e71d7e419f3f6eae836375623d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a2cbce5e71d7e419f3f6eae836375623d">More...</a><br /></td></tr>
<tr class="separator:a2cbce5e71d7e419f3f6eae836375623d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d9df8d8ee8227118b7ec4acbf2c7c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a63d9df8d8ee8227118b7ec4acbf2c7c0">hasShaderBasedTechnique</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;materialName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;groupName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;srcTechniqueSchemeName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;dstTechniqueSchemeName) const</td></tr>
<tr class="memdesc:a63d9df8d8ee8227118b7ec4acbf2c7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a shader based technique has been created for a given technique.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a63d9df8d8ee8227118b7ec4acbf2c7c0">More...</a><br /></td></tr>
<tr class="separator:a63d9df8d8ee8227118b7ec4acbf2c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6378d5b1199e5be790469eae6e535de7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a6378d5b1199e5be790469eae6e535de7">invalidateMaterial</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName, const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;mat)</td></tr>
<tr class="memdesc:a6378d5b1199e5be790469eae6e535de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a6378d5b1199e5be790469eae6e535de7">More...</a><br /></td></tr>
<tr class="separator:a6378d5b1199e5be790469eae6e535de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62782289b008fd98693ac49a14fef58a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a62782289b008fd98693ac49a14fef58a">invalidateMaterial</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;materialName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;groupName=<a class="el" href="group___resources.html#gad0e16ff2458722373e3eea3b303e52da">RGN_DEFAULT</a>)</td></tr>
<tr class="memdesc:a62782289b008fd98693ac49a14fef58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate specific material scheme.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a62782289b008fd98693ac49a14fef58a">More...</a><br /></td></tr>
<tr class="separator:a62782289b008fd98693ac49a14fef58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af452809bad58cd56ea0f3121f216f86c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af452809bad58cd56ea0f3121f216f86c">invalidateMaterialIlluminationPasses</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;materialName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;groupName=<a class="el" href="group___resources.html#gad0e16ff2458722373e3eea3b303e52da">RGN_DEFAULT</a>)</td></tr>
<tr class="memdesc:af452809bad58cd56ea0f3121f216f86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate specific material scheme.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af452809bad58cd56ea0f3121f216f86c">More...</a><br /></td></tr>
<tr class="separator:af452809bad58cd56ea0f3121f216f86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4853e5eea4d5e3c1d0e09e40d9424da1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a4853e5eea4d5e3c1d0e09e40d9424da1">invalidateScheme</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName)</td></tr>
<tr class="memdesc:a4853e5eea4d5e3c1d0e09e40d9424da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate a given scheme.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a4853e5eea4d5e3c1d0e09e40d9424da1">More...</a><br /></td></tr>
<tr class="separator:a4853e5eea4d5e3c1d0e09e40d9424da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f84b4afc636a6fbe754495b916e5e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ae8f84b4afc636a6fbe754495b916e5e3">removeAllShaderBasedTechniques</a> ()</td></tr>
<tr class="memdesc:ae8f84b4afc636a6fbe754495b916e5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all shader based techniques that created by this shader generator.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ae8f84b4afc636a6fbe754495b916e5e3">More...</a><br /></td></tr>
<tr class="separator:ae8f84b4afc636a6fbe754495b916e5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689090fe9be1929029c87223d58e60b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a689090fe9be1929029c87223d58e60b3">removeAllShaderBasedTechniques</a> (const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;mat)</td></tr>
<tr class="memdesc:a689090fe9be1929029c87223d58e60b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a689090fe9be1929029c87223d58e60b3">More...</a><br /></td></tr>
<tr class="separator:a689090fe9be1929029c87223d58e60b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab5086adb3a56a780637461a002d36d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a8ab5086adb3a56a780637461a002d36d">removeAllShaderBasedTechniques</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;materialName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;groupName=<a class="el" href="group___resources.html#gad0e16ff2458722373e3eea3b303e52da">RGN_DEFAULT</a>)</td></tr>
<tr class="memdesc:a8ab5086adb3a56a780637461a002d36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all shader based techniques of the given material.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a8ab5086adb3a56a780637461a002d36d">More...</a><br /></td></tr>
<tr class="separator:a8ab5086adb3a56a780637461a002d36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167695ce8af44af85c7ed4e012e6d350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a167695ce8af44af85c7ed4e012e6d350">removeSceneManager</a> (<a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *sceneMgr)</td></tr>
<tr class="memdesc:a167695ce8af44af85c7ed4e012e6d350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a scene manager from the shader generator scene managers list.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a167695ce8af44af85c7ed4e012e6d350">More...</a><br /></td></tr>
<tr class="separator:a167695ce8af44af85c7ed4e012e6d350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7231ec7b32243201531f67bff6e77640"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a7231ec7b32243201531f67bff6e77640">removeShaderBasedTechnique</a> (const <a class="el" href="class_ogre_1_1_technique.html">Technique</a> *srcTech, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;dstTechniqueSchemeName)</td></tr>
<tr class="memdesc:a7231ec7b32243201531f67bff6e77640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove shader based technique from a given technique.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a7231ec7b32243201531f67bff6e77640">More...</a><br /></td></tr>
<tr class="separator:a7231ec7b32243201531f67bff6e77640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae780004f2d5a93b4b5fcab9bf43c1675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ae780004f2d5a93b4b5fcab9bf43c1675">removeSubRenderStateFactory</a> (<a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html">SubRenderStateFactory</a> *factory)</td></tr>
<tr class="memdesc:ae780004f2d5a93b4b5fcab9bf43c1675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove sub render state factory.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ae780004f2d5a93b4b5fcab9bf43c1675">More...</a><br /></td></tr>
<tr class="separator:ae780004f2d5a93b4b5fcab9bf43c1675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c970e9efeb393e16e444cef32ce14e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a9c970e9efeb393e16e444cef32ce14e3">setCreateShaderOverProgrammablePass</a> (bool value)</td></tr>
<tr class="memdesc:a9c970e9efeb393e16e444cef32ce14e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether shaders are created for passes with shaders.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a9c970e9efeb393e16e444cef32ce14e3">More...</a><br /></td></tr>
<tr class="separator:a9c970e9efeb393e16e444cef32ce14e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e14804413a55ba50b7f12b6c7cd97d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a6e14804413a55ba50b7f12b6c7cd97d9">setShaderCachePath</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;cachePath)</td></tr>
<tr class="memdesc:a6e14804413a55ba50b7f12b6c7cd97d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output shader cache path.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a6e14804413a55ba50b7f12b6c7cd97d9">More...</a><br /></td></tr>
<tr class="separator:a6e14804413a55ba50b7f12b6c7cd97d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264be6eb409744fec0b1ecb897afd5ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a264be6eb409744fec0b1ecb897afd5ea">setShaderProfiles</a> (<a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a> type, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;shaderProfiles)</td></tr>
<tr class="memdesc:a264be6eb409744fec0b1ecb897afd5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output shader target profiles.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a264be6eb409744fec0b1ecb897afd5ea">More...</a><br /></td></tr>
<tr class="separator:a264be6eb409744fec0b1ecb897afd5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a1eee36bfe30841e676639f97f665b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a49a1eee36bfe30841e676639f97f665b">setTargetLanguage</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;shaderLanguage)</td></tr>
<tr class="memdesc:a49a1eee36bfe30841e676639f97f665b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target shader language.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a49a1eee36bfe30841e676639f97f665b">More...</a><br /></td></tr>
<tr class="separator:a49a1eee36bfe30841e676639f97f665b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac784b3f7ac300e33ade90143314effaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac784b3f7ac300e33ade90143314effaa">setVertexShaderOutputsCompactPolicy</a> (<a class="el" href="namespace_ogre_1_1_r_t_shader.html#ab0694782a83ac342574ac3cf1e053355">VSOutputCompactPolicy</a> policy)</td></tr>
<tr class="memdesc:ac784b3f7ac300e33ade90143314effaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the vertex shader outputs compaction policy.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac784b3f7ac300e33ade90143314effaa">More...</a><br /></td></tr>
<tr class="separator:ac784b3f7ac300e33ade90143314effaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3ded51ae63c0120b321d340d667703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#aab3ded51ae63c0120b321d340d667703">validateMaterial</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName, const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;mat)</td></tr>
<tr class="memdesc:aab3ded51ae63c0120b321d340d667703"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#aab3ded51ae63c0120b321d340d667703">More...</a><br /></td></tr>
<tr class="separator:aab3ded51ae63c0120b321d340d667703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c707c5cbc981badceb9946728c708e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a5c707c5cbc981badceb9946728c708e6">validateMaterial</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;materialName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;groupName=<a class="el" href="group___resources.html#gad0e16ff2458722373e3eea3b303e52da">RGN_DEFAULT</a>)</td></tr>
<tr class="memdesc:a5c707c5cbc981badceb9946728c708e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate specific material scheme.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a5c707c5cbc981badceb9946728c708e6">More...</a><br /></td></tr>
<tr class="separator:a5c707c5cbc981badceb9946728c708e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba60c37a422d8834a02108cb98c9890e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#aba60c37a422d8834a02108cb98c9890e">validateMaterialIlluminationPasses</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;materialName, const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;groupName=<a class="el" href="group___resources.html#gad0e16ff2458722373e3eea3b303e52da">RGN_DEFAULT</a>)</td></tr>
<tr class="memdesc:aba60c37a422d8834a02108cb98c9890e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate specific material scheme.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#aba60c37a422d8834a02108cb98c9890e">More...</a><br /></td></tr>
<tr class="separator:aba60c37a422d8834a02108cb98c9890e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651a5f61020937cc40f4090f1f18e458"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a651a5f61020937cc40f4090f1f18e458">validateScheme</a> (const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;schemeName)</td></tr>
<tr class="memdesc:a651a5f61020937cc40f4090f1f18e458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a given scheme.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a651a5f61020937cc40f4090f1f18e458">More...</a><br /></td></tr>
<tr class="separator:a651a5f61020937cc40f4090f1f18e458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_ogre_1_1_singleton"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_ogre_1_1_singleton')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_ogre_1_1_singleton.html">Ogre::Singleton&lt; ShaderGenerator &gt;</a></td></tr>
<tr class="memitem:a2b0622a1223ac3a0c6b9c53e787b8d93 inherit pub_methods_class_ogre_1_1_singleton"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_singleton.html#a2b0622a1223ac3a0c6b9c53e787b8d93">Singleton</a> (void)</td></tr>
<tr class="separator:a2b0622a1223ac3a0c6b9c53e787b8d93 inherit pub_methods_class_ogre_1_1_singleton"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc0518bb06d12629e287149cdcc4b5d inherit pub_methods_class_ogre_1_1_singleton"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_singleton.html#a9bc0518bb06d12629e287149cdcc4b5d">~Singleton</a> (void)</td></tr>
<tr class="separator:a9bc0518bb06d12629e287149cdcc4b5d inherit pub_methods_class_ogre_1_1_singleton"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a320c232700a45276ec30b54bcc7922c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a320c232700a45276ec30b54bcc7922c7">destroy</a> ()</td></tr>
<tr class="memdesc:a320c232700a45276ec30b54bcc7922c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the Shader Generator instance.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a320c232700a45276ec30b54bcc7922c7">More...</a><br /></td></tr>
<tr class="separator:a320c232700a45276ec30b54bcc7922c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb10986f3119e6bdf473e0ee851bf3ae"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html">ShaderGenerator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#aeb10986f3119e6bdf473e0ee851bf3ae">getSingleton</a> ()</td></tr>
<tr class="memdesc:aeb10986f3119e6bdf473e0ee851bf3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override standard <a class="el" href="class_ogre_1_1_singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> retrieval.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#aeb10986f3119e6bdf473e0ee851bf3ae">More...</a><br /></td></tr>
<tr class="separator:aeb10986f3119e6bdf473e0ee851bf3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd96bb2cad55be69d0fe8c6dc28d3590"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html">ShaderGenerator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">getSingletonPtr</a> ()</td></tr>
<tr class="memdesc:acd96bb2cad55be69d0fe8c6dc28d3590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the singleton instance.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">More...</a><br /></td></tr>
<tr class="separator:acd96bb2cad55be69d0fe8c6dc28d3590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad206fa320c81f6482dbe6898a2aec260"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">initialize</a> ()</td></tr>
<tr class="memdesc:ad206fa320c81f6482dbe6898a2aec260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Shader Generator System.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">More...</a><br /></td></tr>
<tr class="separator:ad206fa320c81f6482dbe6898a2aec260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_ogre_1_1_singleton"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_ogre_1_1_singleton')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_ogre_1_1_singleton.html">Ogre::Singleton&lt; ShaderGenerator &gt;</a></td></tr>
<tr class="memitem:a7757bd7ac3702c144502e53ad6491888 inherit pub_static_methods_class_ogre_1_1_singleton"><td class="memItemLeft" align="right" valign="top">static ShaderGenerator &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_singleton.html#a7757bd7ac3702c144502e53ad6491888">getSingleton</a> (void)</td></tr>
<tr class="memdesc:a7757bd7ac3702c144502e53ad6491888 inherit pub_static_methods_class_ogre_1_1_singleton"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the singleton instance.  <a href="class_ogre_1_1_singleton.html#a7757bd7ac3702c144502e53ad6491888">More...</a><br /></td></tr>
<tr class="separator:a7757bd7ac3702c144502e53ad6491888 inherit pub_static_methods_class_ogre_1_1_singleton"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab51c46521b89723d6186a52a7e0d7b inherit pub_static_methods_class_ogre_1_1_singleton"><td class="memItemLeft" align="right" valign="top">static ShaderGenerator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_singleton.html#a7ab51c46521b89723d6186a52a7e0d7b">getSingletonPtr</a> (void)</td></tr>
<tr class="memdesc:a7ab51c46521b89723d6186a52a7e0d7b inherit pub_static_methods_class_ogre_1_1_singleton"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the singleton instance.  <a href="class_ogre_1_1_singleton.html#a7ab51c46521b89723d6186a52a7e0d7b">More...</a><br /></td></tr>
<tr class="separator:a7ab51c46521b89723d6186a52a7e0d7b inherit pub_static_methods_class_ogre_1_1_singleton"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a50a41bdc60047796354703d8d77d028a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">DEFAULT_SCHEME_NAME</a></td></tr>
<tr class="memdesc:a50a41bdc60047796354703d8d77d028a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default material scheme of the shader generator.  <a href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">More...</a><br /></td></tr>
<tr class="separator:a50a41bdc60047796354703d8d77d028a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Shader generator system main interface. </p>
<p>This singleton based class enables automatic generation of shader code based on existing material techniques. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac7eb87c69e1a22e1ad0c0c4a3a9dded1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7eb87c69e1a22e1ad0c0c4a3a9dded1">&#9670;&nbsp;</a></span>RenderStateCreateOrRetrieveResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">RenderState</a>*, bool&gt; <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac7eb87c69e1a22e1ad0c0c4a3a9dded1">Ogre::RTShader::ShaderGenerator::RenderStateCreateOrRetrieveResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad206fa320c81f6482dbe6898a2aec260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad206fa320c81f6482dbe6898a2aec260">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ogre::RTShader::ShaderGenerator::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the Shader Generator System. </p>
<p>Return true upon success. </p>

</div>
</div>
<a id="a320c232700a45276ec30b54bcc7922c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320c232700a45276ec30b54bcc7922c7">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::RTShader::ShaderGenerator::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the Shader Generator instance. </p>

</div>
</div>
<a id="aeb10986f3119e6bdf473e0ee851bf3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb10986f3119e6bdf473e0ee851bf3ae">&#9670;&nbsp;</a></span>getSingleton()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html">ShaderGenerator</a>&amp; Ogre::RTShader::ShaderGenerator::getSingleton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override standard <a class="el" href="class_ogre_1_1_singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> retrieval. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Why do we do this? Well, it's because the <a class="el" href="class_ogre_1_1_singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the <a class="el" href="class_ogre_1_1_singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> template to work, but we actually only want it compiled into the implementation of the class based on the <a class="el" href="class_ogre_1_1_singleton.html" title="Template class for creating single-instance global classes.">Singleton</a>, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. </dd></dl>
<dl class="section user"><dt></dt><dd>This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </dd></dl>

</div>
</div>
<a id="acd96bb2cad55be69d0fe8c6dc28d3590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd96bb2cad55be69d0fe8c6dc28d3590">&#9670;&nbsp;</a></span>getSingletonPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html">ShaderGenerator</a>* Ogre::RTShader::ShaderGenerator::getSingletonPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the singleton instance. </p>

</div>
</div>
<a id="a60704776c069e2a6bd37692f88c56815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60704776c069e2a6bd37692f88c56815">&#9670;&nbsp;</a></span>addSceneManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::addSceneManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneMgr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a scene manager to the shader generator scene managers list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneMgr</td><td>The scene manager to add to the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a167695ce8af44af85c7ed4e012e6d350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167695ce8af44af85c7ed4e012e6d350">&#9670;&nbsp;</a></span>removeSceneManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::removeSceneManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneMgr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a scene manager from the shader generator scene managers list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneMgr</td><td>The scene manager to remove from the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8adc0f4b3a70aed7eecb2b88d399588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8adc0f4b3a70aed7eecb2b88d399588">&#9670;&nbsp;</a></span>getActiveSceneManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a>* Ogre::RTShader::ShaderGenerator::getActiveSceneManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the active scene manager that is doint the actual scene rendering. </p>
<p>This attribute will be update on the call to preFindVisibleObjects. </p>

</div>
</div>
<a id="a4724bbbba4c2e18a7306f98cdfa8ffe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4724bbbba4c2e18a7306f98cdfa8ffe1">&#9670;&nbsp;</a></span>_setActiveSceneManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::_setActiveSceneManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>sceneManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the active scene manager against which new render states are compiled. </p>
<p>Note that normally the setting of the active scene manager is updated through the preFindVisibleObjects method. </p>

</div>
</div>
<a id="a49a1eee36bfe30841e676639f97f665b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a1eee36bfe30841e676639f97f665b">&#9670;&nbsp;</a></span>setTargetLanguage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::setTargetLanguage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>shaderLanguage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target shader language. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderLanguage</td><td>The output shader language to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The default shader language is cg. </dd></dl>

</div>
</div>
<a id="a7a0c4cd10d66291d77f43267d52b73e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0c4cd10d66291d77f43267d52b73e3">&#9670;&nbsp;</a></span>getTargetLanguage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::RTShader::ShaderGenerator::getTargetLanguage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the target shader language currently in use. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a264be6eb409744fec0b1ecb897afd5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264be6eb409744fec0b1ecb897afd5ea">&#9670;&nbsp;</a></span>setShaderProfiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::setShaderProfiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>shaderProfiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the output shader target profiles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>shader type </td></tr>
    <tr><td class="paramname">shaderProfiles</td><td>The target profiles for the shader. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61dc9c750980554a61a18ec1f983fae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dc9c750980554a61a18ec1f983fae2">&#9670;&nbsp;</a></span>getShaderProfiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::RTShader::ShaderGenerator::getShaderProfiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the output shader target profiles. </p>

</div>
</div>
<a id="a6e14804413a55ba50b7f12b6c7cd97d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e14804413a55ba50b7f12b6c7cd97d9">&#9670;&nbsp;</a></span>setShaderCachePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::setShaderCachePath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>cachePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the output shader cache path. </p>
<p>Generated shader code will be written to this path. <a class="el" href="struct_ogre_1_1_r_t_shader_1_1_in.html">In</a> case of empty cache path shaders will be generated directly from system memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cachePath</td><td>The cache path of the shader. <br  />
 The default is empty cache path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f0a1b86511924d42a007d092af0900c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0a1b86511924d42a007d092af0900c">&#9670;&nbsp;</a></span>getShaderCachePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::RTShader::ShaderGenerator::getShaderCachePath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the output shader cache path. </p>

</div>
</div>
<a id="a2f6479b03aee3ab7160187ecfc86604a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6479b03aee3ab7160187ecfc86604a">&#9670;&nbsp;</a></span>flushShaderCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::flushShaderCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the shader cache. </p>
<p>This operation will cause all active schemes to be invalidated and will destroy any CPU/GPU program that created by this shader generator. </p>

</div>
</div>
<a id="a3d7167dbc5b45f11cae4a5dc61c0a823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7167dbc5b45f11cae4a5dc61c0a823">&#9670;&nbsp;</a></span>getRenderState() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">RenderState</a>* Ogre::RTShader::ShaderGenerator::getRenderState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a global render state associated with the given scheme name. </p>
<p>Modifying this render state will affect all techniques that belongs to that scheme. This is the best way to apply global changes to all techniques. After altering the render state one should call invalidateScheme method in order to regenerate shaders. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemeName</td><td>The destination scheme name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7db5e39bdc0c411e5052b99f1655f75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db5e39bdc0c411e5052b99f1655f75e">&#9670;&nbsp;</a></span>createOrRetrieveRenderState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac7eb87c69e1a22e1ad0c0c4a3a9dded1">RenderStateCreateOrRetrieveResult</a> Ogre::RTShader::ShaderGenerator::createOrRetrieveRenderState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a requested render state. </p>
<p>If the render state does not exist this function creates it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemeName</td><td>The scheme name to retrieve. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51041e1b67f991880265f8c92081a984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51041e1b67f991880265f8c92081a984">&#9670;&nbsp;</a></span>hasRenderState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::hasRenderState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells if a given render state exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemeName</td><td>The scheme name to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c475bb3a78d796d1f28407b3a476712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c475bb3a78d796d1f28407b3a476712">&#9670;&nbsp;</a></span>getRenderState() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">RenderState</a>* Ogre::RTShader::ShaderGenerator::getRenderState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>passIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get render state of specific pass. </p>
<p>Using this method allows the user to customize the behavior of a specific pass. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemeName</td><td>The destination scheme name. </td></tr>
    <tr><td class="paramname">materialName</td><td>The specific material name. </td></tr>
    <tr><td class="paramname">groupName</td><td>The specific material name. </td></tr>
    <tr><td class="paramname">passIndex</td><td>The pass index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3a62e6db3899eed370e00d96170a74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a62e6db3899eed370e00d96170a74b">&#9670;&nbsp;</a></span>getRenderState() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">RenderState</a>* Ogre::RTShader::ShaderGenerator::getRenderState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a>&#160;</td>
          <td class="paramname"><em>passIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_resource.html#a050f1801ae76012efe745bc472e9f4f9">Ogre::Resource::getGroup()</a>, and <a class="el" href="class_ogre_1_1_resource.html#aad179b0f7c05ff3754e486e7352b93b6">Ogre::Resource::getName()</a>.</p>

</div>
</div>
<a id="ac266946244d79b2d4732607ae9479bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac266946244d79b2d4732607ae9479bd9">&#9670;&nbsp;</a></span>addSubRenderStateFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html">SubRenderStateFactory</a> *&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add sub render state factory. </p>
<p>Plugins or 3d party applications may implement sub classes of <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline.">SubRenderState</a> interface. Add the matching factory will allow the application to create instances of these sub classes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The factory to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96fee1229b6cd03d9da70e58e3290848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fee1229b6cd03d9da70e58e3290848">&#9670;&nbsp;</a></span>getNumSubRenderStateFactories()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::RTShader::ShaderGenerator::getNumSubRenderStateFactories </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of existing factories. </p>

</div>
</div>
<a id="a1d439aa0c31457ae0341e55f97e08219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d439aa0c31457ae0341e55f97e08219">&#9670;&nbsp;</a></span>getSubRenderStateFactory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html">SubRenderStateFactory</a>* Ogre::RTShader::ShaderGenerator::getSubRenderStateFactory </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a sub render state factory by index. </p>
<dl class="section note"><dt>Note</dt><dd>index must be lower than the value returned by <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a96fee1229b6cd03d9da70e58e3290848" title="Returns the number of existing factories.">getNumSubRenderStateFactories()</a> </dd></dl>

</div>
</div>
<a id="aa60196108386f7ca4a82a56eff383242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60196108386f7ca4a82a56eff383242">&#9670;&nbsp;</a></span>getSubRenderStateFactory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html">SubRenderStateFactory</a>* Ogre::RTShader::ShaderGenerator::getSubRenderStateFactory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a sub render state factory by name. </p>

</div>
</div>
<a id="ae780004f2d5a93b4b5fcab9bf43c1675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae780004f2d5a93b4b5fcab9bf43c1675">&#9670;&nbsp;</a></span>removeSubRenderStateFactory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::removeSubRenderStateFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html">SubRenderStateFactory</a> *&#160;</td>
          <td class="paramname"><em>factory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove sub render state factory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>The factory to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4fe4ab6a8fb0e1b2ba67e2506b1e992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fe4ab6a8fb0e1b2ba67e2506b1e992">&#9670;&nbsp;</a></span>createSubRenderState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">SubRenderState</a>* Ogre::RTShader::ShaderGenerator::createSubRenderState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an instance of sub render state from a given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of sub render state to create. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a512dbd23cc30a2dd2c5c344d1faac0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512dbd23cc30a2dd2c5c344d1faac0d2">&#9670;&nbsp;</a></span>createSubRenderState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* Ogre::RTShader::ShaderGenerator::createSubRenderState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a59a2d06db88797395cf55f6d84595205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a2d06db88797395cf55f6d84595205">&#9670;&nbsp;</a></span>destroySubRenderState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::destroySubRenderState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">SubRenderState</a> *&#160;</td>
          <td class="paramname"><em>subRenderState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an instance of sub render state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subRenderState</td><td>The instance to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63d9df8d8ee8227118b7ec4acbf2c7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d9df8d8ee8227118b7ec4acbf2c7c0">&#9670;&nbsp;</a></span>hasShaderBasedTechnique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::hasShaderBasedTechnique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>srcTechniqueSchemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>dstTechniqueSchemeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a shader based technique has been created for a given technique. </p>
<p>Return true if exist. False if not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">materialName</td><td>The source material name. </td></tr>
    <tr><td class="paramname">groupName</td><td>The source group name. </td></tr>
    <tr><td class="paramname">srcTechniqueSchemeName</td><td>The source technique scheme name. </td></tr>
    <tr><td class="paramname">dstTechniqueSchemeName</td><td>The destination shader based technique scheme name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cbce5e71d7e419f3f6eae836375623d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbce5e71d7e419f3f6eae836375623d">&#9670;&nbsp;</a></span>hasShaderBasedTechnique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::hasShaderBasedTechnique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>srcTechniqueSchemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>dstTechniqueSchemeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_resource.html#a050f1801ae76012efe745bc472e9f4f9">Ogre::Resource::getGroup()</a>, and <a class="el" href="class_ogre_1_1_resource.html#aad179b0f7c05ff3754e486e7352b93b6">Ogre::Resource::getName()</a>.</p>

</div>
</div>
<a id="af02d3e93da75e66ed3312b5790d18868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02d3e93da75e66ed3312b5790d18868">&#9670;&nbsp;</a></span>createShaderBasedTechnique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;&#160;</td>
          <td class="paramname"><em>srcMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>srcTechniqueSchemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>dstTechniqueSchemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overProgrammable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create shader based technique from a given technique. </p>
<p>Return true upon success. Failure may occur if the source technique is not FFP pure, or different source technique is mapped to the requested destination scheme. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcMat</td><td>The source material. </td></tr>
    <tr><td class="paramname">srcTechniqueSchemeName</td><td>The source technique scheme name. </td></tr>
    <tr><td class="paramname">dstTechniqueSchemeName</td><td>The destination shader based technique scheme name. </td></tr>
    <tr><td class="paramname">overProgrammable</td><td>If true a shader will be created even if the pass already has shaders </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a701b44491228077d3e2aca6a49f94499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701b44491228077d3e2aca6a49f94499">&#9670;&nbsp;</a></span>createShaderBasedTechnique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_technique.html">Technique</a> *&#160;</td>
          <td class="paramname"><em>srcTech</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>dstTechniqueSchemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overProgrammable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a7231ec7b32243201531f67bff6e77640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7231ec7b32243201531f67bff6e77640">&#9670;&nbsp;</a></span>removeShaderBasedTechnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::removeShaderBasedTechnique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_technique.html">Technique</a> *&#160;</td>
          <td class="paramname"><em>srcTech</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>dstTechniqueSchemeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove shader based technique from a given technique. </p>
<p>Return true upon success. Failure may occur if the given source technique was not previously registered successfully using the createShaderBasedTechnique method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcTech</td><td>The source technique. </td></tr>
    <tr><td class="paramname">dstTechniqueSchemeName</td><td>The destination shader based technique scheme name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ab5086adb3a56a780637461a002d36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab5086adb3a56a780637461a002d36d">&#9670;&nbsp;</a></span>removeAllShaderBasedTechniques() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::removeAllShaderBasedTechniques </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="group___resources.html#gad0e16ff2458722373e3eea3b303e52da">RGN_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all shader based techniques of the given material. </p>
<p>Return true upon success. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">materialName</td><td>The source material name. <br  />
 </td></tr>
    <tr><td class="paramname">groupName</td><td>The source group name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a689090fe9be1929029c87223d58e60b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689090fe9be1929029c87223d58e60b3">&#9670;&nbsp;</a></span>removeAllShaderBasedTechniques() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::removeAllShaderBasedTechniques </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_resource.html#a050f1801ae76012efe745bc472e9f4f9">Ogre::Resource::getGroup()</a>, and <a class="el" href="class_ogre_1_1_resource.html#aad179b0f7c05ff3754e486e7352b93b6">Ogre::Resource::getName()</a>.</p>

</div>
</div>
<a id="a54f9e8965650ed9c2fc35e72ae2aa1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f9e8965650ed9c2fc35e72ae2aa1e3">&#9670;&nbsp;</a></span>cloneShaderBasedTechniques()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::cloneShaderBasedTechniques </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;&#160;</td>
          <td class="paramname"><em>srcMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone all shader based techniques from one material to another. </p>
<p>This function can be used in conjunction with the <a class="el" href="class_ogre_1_1_material.html#ad4886c5f0e4e029a161e589c8a410004" title="Creates a new copy of this material with the same settings but a new name.">Material::clone()</a> function to copy both material properties and RTSS state from one material to another. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcMat</td><td>The source material </td></tr>
    <tr><td class="paramname">dstMat</td><td>The destination material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful </dd></dl>

</div>
</div>
<a id="ae8f84b4afc636a6fbe754495b916e5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f84b4afc636a6fbe754495b916e5e3">&#9670;&nbsp;</a></span>removeAllShaderBasedTechniques() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::removeAllShaderBasedTechniques </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all shader based techniques that created by this shader generator. </p>
<p><br  />
 </p>

</div>
</div>
<a id="a4d27197d6de2e7b02bf0127cc9619081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d27197d6de2e7b02bf0127cc9619081">&#9670;&nbsp;</a></span>createScheme()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::createScheme </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemeName</td><td>The scheme name to create. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4853e5eea4d5e3c1d0e09e40d9424da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4853e5eea4d5e3c1d0e09e40d9424da1">&#9670;&nbsp;</a></span>invalidateScheme()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::invalidateScheme </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate a given scheme. </p>
<p>This action will lead to shader regeneration of all techniques belongs to the given scheme name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemeName</td><td>The scheme to invalidate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a651a5f61020937cc40f4090f1f18e458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651a5f61020937cc40f4090f1f18e458">&#9670;&nbsp;</a></span>validateScheme()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::validateScheme </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate a given scheme. </p>
<p>This action will generate shader programs for all techniques of the given scheme name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemeName</td><td>The scheme to validate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62782289b008fd98693ac49a14fef58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62782289b008fd98693ac49a14fef58a">&#9670;&nbsp;</a></span>invalidateMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::invalidateMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="group___resources.html#gad0e16ff2458722373e3eea3b303e52da">RGN_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate specific material scheme. </p>
<p>This action will lead to shader regeneration of the technique belongs to the given scheme name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemeName</td><td>The scheme to invalidate. </td></tr>
    <tr><td class="paramname">materialName</td><td>The material to invalidate. </td></tr>
    <tr><td class="paramname">groupName</td><td>The source group name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6378d5b1199e5be790469eae6e535de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6378d5b1199e5be790469eae6e535de7">&#9670;&nbsp;</a></span>invalidateMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::invalidateMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_resource.html#a050f1801ae76012efe745bc472e9f4f9">Ogre::Resource::getGroup()</a>, and <a class="el" href="class_ogre_1_1_resource.html#aad179b0f7c05ff3754e486e7352b93b6">Ogre::Resource::getName()</a>.</p>

</div>
</div>
<a id="a5c707c5cbc981badceb9946728c708e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c707c5cbc981badceb9946728c708e6">&#9670;&nbsp;</a></span>validateMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::validateMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="group___resources.html#gad0e16ff2458722373e3eea3b303e52da">RGN_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate specific material scheme. </p>
<p>This action will generate shader programs for the technique of the given scheme name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemeName</td><td>The scheme to validate. </td></tr>
    <tr><td class="paramname">materialName</td><td>The material to validate. </td></tr>
    <tr><td class="paramname">groupName</td><td>The source group name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab3ded51ae63c0120b321d340d667703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3ded51ae63c0120b321d340d667703">&#9670;&nbsp;</a></span>validateMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::validateMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_material.html">Material</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="class_ogre_1_1_resource.html#a050f1801ae76012efe745bc472e9f4f9">Ogre::Resource::getGroup()</a>, and <a class="el" href="class_ogre_1_1_resource.html#aad179b0f7c05ff3754e486e7352b93b6">Ogre::Resource::getName()</a>.</p>

</div>
</div>
<a id="af452809bad58cd56ea0f3121f216f86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af452809bad58cd56ea0f3121f216f86c">&#9670;&nbsp;</a></span>invalidateMaterialIlluminationPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::invalidateMaterialIlluminationPasses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="group___resources.html#gad0e16ff2458722373e3eea3b303e52da">RGN_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate specific material scheme. </p>
<p>This action will lead to shader regeneration of the technique belongs to the given scheme name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemeName</td><td>The scheme to invalidate. </td></tr>
    <tr><td class="paramname">materialName</td><td>The material to invalidate. </td></tr>
    <tr><td class="paramname">groupName</td><td>The source group name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba60c37a422d8834a02108cb98c9890e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba60c37a422d8834a02108cb98c9890e">&#9670;&nbsp;</a></span>validateMaterialIlluminationPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::validateMaterialIlluminationPasses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>schemeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="group___resources.html#gad0e16ff2458722373e3eea3b303e52da">RGN_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate specific material scheme. </p>
<p>This action will generate shader programs illumination passes of the technique of the given scheme name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schemeName</td><td>The scheme to validate. </td></tr>
    <tr><td class="paramname">materialName</td><td>The material to validate. </td></tr>
    <tr><td class="paramname">groupName</td><td>The source group name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a416c5013cc01c0f9b64ca98a50a202f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416c5013cc01c0f9b64ca98a50a202f4">&#9670;&nbsp;</a></span>getMaterialSerializerListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_material_serializer_1_1_listener.html">MaterialSerializer::Listener</a>* Ogre::RTShader::ShaderGenerator::getMaterialSerializerListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return custom material <a class="el" href="class_ogre_1_1_serializer.html" title="Generic class for serialising data to / from binary stream-based files.">Serializer</a> of the shader generator. </p>
<p>This is useful when you'd like to export certain material that contains shader generator effects. I.E - when writing an exporter you may want mark your material as shader generated material so in the next time you will load it by your application it will automatically generate shaders with custom attributes you wanted. To do it you'll have to do the following steps:</p><ol type="1">
<li>Create shader based technique for you material via the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique.">createShaderBasedTechnique()</a> method.</li>
<li>Create <a class="el" href="class_ogre_1_1_material_serializer.html" title="Class for serializing Materials to a .material script.">MaterialSerializer</a> instance.</li>
<li>Add the return instance of serializer listener to the <a class="el" href="class_ogre_1_1_material_serializer.html" title="Class for serializing Materials to a .material script.">MaterialSerializer</a>.</li>
<li>Call one of the export methods of <a class="el" href="class_ogre_1_1_material_serializer.html" title="Class for serializing Materials to a .material script.">MaterialSerializer</a>. </li>
</ol>

</div>
</div>
<a id="af5c45f520b80e490a398b5d3c625463a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c45f520b80e490a398b5d3c625463a">&#9670;&nbsp;</a></span>getShaderCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::RTShader::ShaderGenerator::getShaderCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___resources.html#gafe603a6463467ab5f7e43721fe8ef96e">GpuProgramType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current number of generated shaders. </p>

</div>
</div>
<a id="ac784b3f7ac300e33ade90143314effaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac784b3f7ac300e33ade90143314effaa">&#9670;&nbsp;</a></span>setVertexShaderOutputsCompactPolicy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::setVertexShaderOutputsCompactPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre_1_1_r_t_shader.html#ab0694782a83ac342574ac3cf1e053355">VSOutputCompactPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the vertex shader outputs compaction policy. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_ogre_1_1_r_t_shader.html#ab0694782a83ac342574ac3cf1e053355">VSOutputCompactPolicy</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>The policy to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e4f0f0f8724ac9d60e76409cdd3ec01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4f0f0f8724ac9d60e76409cdd3ec01">&#9670;&nbsp;</a></span>getVertexShaderOutputsCompactPolicy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre_1_1_r_t_shader.html#ab0694782a83ac342574ac3cf1e053355">VSOutputCompactPolicy</a> Ogre::RTShader::ShaderGenerator::getVertexShaderOutputsCompactPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vertex shader outputs compaction policy. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_ogre_1_1_r_t_shader.html#ab0694782a83ac342574ac3cf1e053355">VSOutputCompactPolicy</a>. </dd></dl>

</div>
</div>
<a id="a9c970e9efeb393e16e444cef32ce14e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c970e9efeb393e16e444cef32ce14e3">&#9670;&nbsp;</a></span>setCreateShaderOverProgrammablePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::RTShader::ShaderGenerator::setCreateShaderOverProgrammablePass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether shaders are created for passes with shaders. </p>
<p>Note that this only refers to when the system parses the materials itself. Not for when calling the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique.">createShaderBasedTechnique()</a> function directly </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to set this attribute pass. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6de4a29532eeca2dd8f8a44e78c05e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de4a29532eeca2dd8f8a44e78c05e3a">&#9670;&nbsp;</a></span>getCreateShaderOverProgrammablePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::RTShader::ShaderGenerator::getCreateShaderOverProgrammablePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether shaders are created for passes with shaders. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a9c970e9efeb393e16e444cef32ce14e3" title="Sets whether shaders are created for passes with shaders.">setCreateShaderOverProgrammablePass()</a>. </dd></dl>

</div>
</div>
<a id="aff76240698adc0202e64be7055613015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff76240698adc0202e64be7055613015">&#9670;&nbsp;</a></span>getRTShaderSchemeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Ogre::RTShader::ShaderGenerator::getRTShaderSchemeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of schemes used in the for RT shader generation. </p>

</div>
</div>
<a id="a8a32eb5519fa040eced4a6c94025dbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a32eb5519fa040eced4a6c94025dbd8">&#9670;&nbsp;</a></span>getRTShaderScheme()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a>&amp; Ogre::RTShader::ShaderGenerator::getRTShaderScheme </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the scheme name used in the for RT shader generation by index. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a50a41bdc60047796354703d8d77d028a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a41bdc60047796354703d8d77d028a">&#9670;&nbsp;</a></span>DEFAULT_SCHEME_NAME</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aaf6cdc855bf9ae5edbf48a7e7dcb27f8">String</a> Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default material scheme of the shader generator. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_shader_generator_8h.html">OgreShaderGenerator.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="namespace_ogre_1_1_r_t_shader.html">RTShader</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html">ShaderGenerator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
