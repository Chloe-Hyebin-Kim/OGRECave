<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Instancing User-Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">13.2</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_what_is_instancing.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Instancing User-Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#InstancesPerBatch">Instances per batch</a></li>
<li class="level1"><a href="#InstancingTechniques">Techniques</a><ul><li class="level2"><a href="#InstancingTechniquesShaderBased">ShaderBased</a></li>
<li class="level2"><a href="#InstancingTechniquesVTFSoftware">VTF (Software)</a></li>
<li class="level2"><a href="#InstancingTechniquesHWVTF">HW VTF</a><ul><li class="level3"><a href="#InstancingTechniquesHW">HW VTF LUT</a></li>
</ul>
</li>
<li class="level2"><a href="#InstancingTechniquesHWBasic">HW Basic</a></li>
</ul>
</li>
<li class="level1"><a href="#InstancingCustomParameters">Custom parameters</a></li>
<li class="level1"><a href="#InstancingMultipleSubmeshes">Supporting multiple submeshes</a></li>
<li class="level1"><a href="#InstancingDefragmentingBatches">Defragmenting batches</a><ul><li class="level2"><a href="#InstancingDefragmentingBatchesIntro">What is batch fragmentation?</a></li>
<li class="level2"><a href="#InstancingDefragmentingBatchesPrevention">Prevention: Avoiding fragmentation</a></li>
<li class="level2"><a href="#InstancingDefragmentingBatchesOnTheFly">Cure: Defragmenting on the fly</a></li>
</ul>
</li>
<li class="level1"><a href="#InstancingTroubleshooting">Troubleshooting</a></li>
</ul>
</div>
<div class="textblock"><p>A common question is why should I use instancing. The big reason is performance. There can be 10x improvements or more when used correctly. Here's a guide on when you should use instancing:</p>
<ol type="1">
<li>You have <em>a lot</em> of Entities that are repeated and based on the same Mesh (i.e. a rock, a building, a tree, loose leaves, enemies, irrelevant crowds or NPCs)</li>
<li>These Entities that repeat a lot also share the same material (or just a few materials, i.e. 3 or 4)</li>
<li>The bottleneck in your game is the CPU.</li>
</ol>
<p>If these three requirements are all met in your game, chances are instancing is for you. There will be minimal gains when using instancing on an Entity that repeats very little, or if each instance actually has a different material, or it could run even slower if the Entity never repeats.</p>
<p>If the bottleneck in your game is not CPU (i.e. it's in the GPU) then instancing won't make a noticeable difference.</p>
<h1><a class="anchor" id="InstancesPerBatch"></a>
Instances per batch</h1>
<p>As explained in the previous section, instancing groups all instances into one draw call. However this is half the truth. Instancing actually groups a certain number of instances into a batch. One batch = One draw call.</p>
<p>If the technique is using 80 instances per batch; then rendering 160 instances is going to need 2 draw calls (two batches); if there are 180 instances, 3 draw calls will be needed (3 batches).</p>
<p>What is a good value for instances-per-batch setting? That depends on a lot of factors, which you will have to profile. Normally, increasing the number should improve performance because the system is most likely CPU bottleneck. However, past certain number, certain trade offs begin to show up:</p>
<ul>
<li>Culling is first performed at batch level, then for HW techniques culling is also done at per instance level. If the batch contains too many instances, its AABB will grow too large; thus the hierarchy culling will always pass and <a class="el" href="namespace_ogre.html">Ogre</a> won't be able skip entire batches.</li>
<li>If the instance per batch is at 10.000 and the application created 10.001 instances; a lot of RAM &amp; VRAM will be wasted because it's set for 20.000 instances; HW techniques will spent an excessive amount of CPU time parsing the 9.999 inactive instances; and SW techniques will saturate the Bus bandwidth sending null matrices for the inactive instances to the GPU.</li>
</ul>
<p>The actual value will depend a lot on the application and whether all instances are often on screen or frustum culled and whether the total number of instances can be known at production time (i.e. environment props). Normally numbers between 80 and 500 work best, but there have been cases where big values like 5.000 actually improved performance.</p>
<h1><a class="anchor" id="InstancingTechniques"></a>
Techniques</h1>
<p><a class="el" href="namespace_ogre.html">Ogre</a> supports 4 different instancing techniques. Unfortunately, each of them requires a different vertex shader, since their approaches are different. Also their compatibility and performance varies.</p>
<h2><a class="anchor" id="InstancingTechniquesShaderBased"></a>
ShaderBased</h2>
<p>This is the most compatible technique. It is a Software Instancing technique. World matrices are passed through constant registers, and thus the maximum number of instances per batch is 80; which quickly goes down if the object is skeletally animated. This technique does not play very well with skeletal animation because of that, unless the number of bones is very low (3 or less).</p>
<p>See <code>material Examples/Instancing/ShaderBased</code> for an example on how to write the vertex shader. (You can find these files in OGRE sources from before v1.12) Files:</p><ul>
<li>ShaderInstancing.material</li>
<li>ShaderInstancing.vert (GLSL)</li>
<li>ShaderInstancing.cg (Cg, works with HLSL)</li>
</ul>
<p>See <code>Examples/Instancing/RTSS/Robot</code> for an example on how to use instancing with the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a></p>
<p>Add to the Vertex Shader input example: </p><div class="fragment"><div class="line">...</div>
<div class="line">float4 blendIdx : BLENDINDICES,</div>
<div class="line">uniform float3x4 worldMatrix3x4Array[80],</div>
<div class="line">...</div>
</div><!-- fragment --><p>Vertex position calculation example: </p><div class="fragment"><div class="line">int idx = int(blendIdx[0]);</div>
<div class="line">float4 worldPos  = float4( mul( worldMatrix3x4Array[idx], position ).xyz, 1.0f );</div>
<div class="line">oClipPos = mul( viewProjMatrix, worldPos );</div>
<div class="line">...</div>
</div><!-- fragment --><h2><a class="anchor" id="InstancingTechniquesVTFSoftware"></a>
VTF (Software)</h2>
<p>VTF stands for "Vertex Texture Fetch". It is a Software Instancing technique. Unlike ShaderBased, world matrices are passed to the vertex shader through a texture. Such feature has only been supported since Vertex Shader 3.0 and is not supported on Radeon X1xxx cards and is quite slow on GeForce 6 &amp; 7. However it's very fast on any modern GPU (GeForce 8, 9, 200, 300, 400, 500, 600, 700; all Radeon HD series, Intel HD 3000 and above)</p>
<p>The advantage of VTF over ShaderBased is that it supports a very high max number of instances per batch; even if it's skeletally animated.</p>
<p>Take note that you will need to set a <code>texture_unit</code> (preferrably the first one, for compatibility) including the shadow caster besides the texture (eg. diffuse, specular, normal maps) so that <a class="el" href="namespace_ogre.html">Ogre</a> gets where to put the vertex texture.</p>
<p>See <code>material Examples/Instancing/VTF</code> for an example on how to write the vertex shader and setup the material. Files:</p><ul>
<li>VTFInstancing.material</li>
<li>VTFInstancing.vert (GLSL)</li>
<li>VTFInstancing.cg (Cg, also works with HLSL)</li>
</ul>
<p>Texture unit example: </p><div class="fragment"><div class="line">texture_unit InstancingVTF</div>
<div class="line">{</div>
<div class="line">    binding_type vertex</div>
<div class="line">    filtering none</div>
<div class="line">}</div>
</div><!-- fragment --><p>Add to Vertex Shader input example: </p><div class="fragment"><div class="line">...</div>
<div class="line">float4 m01 : TEXCOORD1,</div>
<div class="line">float4 m23 : TEXCOORD2,</div>
<div class="line">uniform sampler2D matrixTexture : register(s0), // s0 if texture_unit InstancingVTF appears first</div>
<div class="line">...</div>
</div><!-- fragment --><p>Vertex position calculation example: </p><div class="fragment"><div class="line">float3x4 worldMatrix;</div>
<div class="line">worldMatrix[0] = tex2D( matrixTexture, m01.xy );</div>
<div class="line">worldMatrix[1] = tex2D( matrixTexture, m01.zw );</div>
<div class="line">worldMatrix[2] = tex2D( matrixTexture, m23.xy );</div>
<div class="line">float4 worldPos = float4( mul( worldMatrix, position ).xyz, 1.0f );</div>
<div class="line">oClipPos = mul( viewProjMatrix, worldPos );</div>
<div class="line">...</div>
</div><!-- fragment --><h2><a class="anchor" id="InstancingTechniquesHWVTF"></a>
HW VTF</h2>
<p>This is the same technique as VTF; but implemented through hardware instancing. It is probably one of the best and most flexible techniques.</p>
<p>The vertex shader has to be slightly different from SW VTF version. See <code>material Examples/Instancing/HW_VTF</code> for an example on how to write the vertex shader and setup the material. Files:</p><ul>
<li>HW_VTFInstancing.material</li>
<li>HW_VTFInstancing.vert (GLSL)</li>
<li>HW_VTFInstancing.cg (Cg, works with HLSL)</li>
</ul>
<p>Texture unit example: </p><div class="fragment"><div class="line">texture_unit InstancingVTF</div>
<div class="line">{</div>
<div class="line">    binding_type vertex</div>
<div class="line">    filtering none</div>
<div class="line">}</div>
</div><!-- fragment --><p>Vertex Shader input example: </p><div class="fragment"><div class="line">float4 m03 : TEXCOORD1,</div>
<div class="line">float2 mOffset : TEXCOORD2,</div>
<div class="line">uniform sampler2D matrixTexture : register(s1),</div>
</div><!-- fragment --><p>Vertex position calculation example: </p><div class="fragment"><div class="line">float3x4 worldMatrix;</div>
<div class="line">worldMatrix[0] = tex2D( matrixTexture, m03.xw + mOffset );</div>
<div class="line">worldMatrix[1] = tex2D( matrixTexture, m03.yw + mOffset );</div>
<div class="line">worldMatrix[2] = tex2D( matrixTexture, m03.zw + mOffset );</div>
<div class="line">float4 worldPos = float4( mul( worldMatrix, position ).xyz, 1.0f );</div>
<div class="line">oClipPos = mul( viewProjMatrix, worldPos );</div>
</div><!-- fragment --><h3><a class="anchor" id="InstancingTechniquesHW"></a>
HW VTF LUT</h3>
<p>LUT is a special feature of HW VTF; which stands for <b>L</b>ook <b>U</b>p <b>T</b>able. It has been particularly designed for drawing large animated crowds.</p>
<p>The technique is a trick that works by animating a limited number of instances (i.e. 16 animations) storing them in a look up table in the VTF, and then repeating these animations to all instances uniformly, giving the appearance that all instances are independently animated when seen in large crowds.</p>
<p>See <code>material Examples/Instancing/HW_VTF_LUT</code>. Files:</p><ul>
<li>Same as HW VTF (different macros defined)</li>
</ul>
<p>To enable the use of LUT, <code>SceneManager::createInstanceManager</code>'s flags must include the flag <code>IM_VTFBONEMATRIXLOOKUP</code> and specify HW VTF as technique.</p>
<div class="fragment"><div class="line">mSceneMgr-&gt;createInstanceManager(<span class="stringliteral">&quot;InstanceMgr&quot;</span>,<span class="stringliteral">&quot;MyMesh.mesh&quot;</span>,</div>
<div class="line">            ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME,</div>
<div class="line">            InstanceManager::HWInstancingVTF,</div>
<div class="line">            numInstancesPerBatch,<a class="code" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a0ef5ea7756d41449148c181eef505d92">IM_USEALL</a>|<a class="code" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a2e31b097f5510963d742dce628d868ef">IM_VTFBONEMATRIXLOOKUP</a> );</div>
</div><!-- fragment --><h2><a class="anchor" id="InstancingTechniquesHWBasic"></a>
HW Basic</h2>
<p>HW Basic is probably the fastest instancing technique[^7], but is surely more compatible than HW VTF.</p>
<p>The world matrix data is passed to the vertex shader using a <code>float3x4</code> <code>TEXCOORD</code> (<em>attribute</em> in GLSL jargon) instead of a vertex texture. The other big difference with HW VTF, besides how data is being passed, is that HW Basic doesn't support skeletal animations at all, making it the preferred choice for rendering inanimate objects like trees, falling leaves, buildings, etc.</p>
<p>See <code>material Examples/Instancing/HWBasic</code> for an example. (You can find these files in OGRE sources from before v1.12) Files:</p><ul>
<li>HWInstancing.material</li>
<li>HWBasicInstancing.vert (GLSL)</li>
<li>HWBasicInstancing.cg (Cg, works with HLSL)</li>
</ul>
<p>See <code>Examples/Instancing/RTSS/Robot</code> for an example on how to use instancing with the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a></p>
<p>Vertex Shader input example: </p><div class="fragment"><div class="line">...</div>
<div class="line">float4 mat14 : TEXCOORD1,</div>
<div class="line">float4 mat24 : TEXCOORD2,</div>
<div class="line">float4 mat34 : TEXCOORD3,</div>
<div class="line">...</div>
</div><!-- fragment --><p>Vertex position calculation example: </p><div class="fragment"><div class="line">float3x4 worldMatrix;</div>
<div class="line">worldMatrix[0] = mat14;</div>
<div class="line">worldMatrix[1] = mat24;</div>
<div class="line">worldMatrix[2] = mat34;</div>
<div class="line">float4 worldPos = float4( mul( worldMatrix, position ).xyz, 1.0f );</div>
<div class="line">oClipPos = mul( viewProjMatrix, worldPos );</div>
<div class="line">...</div>
</div><!-- fragment --><h1><a class="anchor" id="InstancingCustomParameters"></a>
Custom parameters</h1>
<p>Some instancing techniques allow passing custom parameters to vertex shaders. For example a custom colour in an RTS game to identify player units; a single value for randomly colouring vegetation, light parameters for rendering deferred shading's light volumes (diffuse colour, specular colour, etc)</p>
<p>At the time of writing only HW Basic supports passing the custom parameters. All other techniques will ignore it.[^8]</p>
<p>To use custom parameters, call <code>InstanceManager::setNumCustomParams</code> to tell the number of custom parameters the user will need. <b>This number cannot be changed after creating the first batch</b> (call createInstancedEntity)</p>
<p>Afterwards, it's just a matter of calling <code>InstancedEntity::setCustomParam</code> with the param you wish to send.</p>
<p>For HW Basic techniques, the vertex shader will receive the custom param in an extra <code>TEXCOORD.</code></p>
<div class="fragment"><div class="line"> InstanceManager *instanceMgr;<span class="comment">//Assumed to be valid ptr</span></div>
<div class="line">instanceMgr-&gt;setNumCustomParams(2);</div>
<div class="line"> </div>
<div class="line">InstancedEntity *instancedEntity =instanceMgr-&gt;createInstancedEntity(<span class="stringliteral">&quot;myMaterial&quot;</span>);</div>
<div class="line">instancedEntity-&gt;setCustomParam(0,<a class="code" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>(1.0f,1.0f,1.2f,0.0f));</div>
<div class="line">instancedEntity-&gt;setCustomParam(1,<a class="code" href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Vector4</a>(0.2f,0.0f,0.7f,1.0f));</div>
</div><!-- fragment --><h1><a class="anchor" id="InstancingMultipleSubmeshes"></a>
Supporting multiple submeshes</h1>
<p>Multiple submeshes means different instance managers, because instancing can only be applied to the same submesh.</p>
<p>Nevertheless, it is actually quite easy to support multiple submeshes. The first step is to create the InstanceManager setting the <code>subMeshIdx</code> parameter to the number of submesh you want to use:</p>
<div class="fragment"><div class="line">std::vector&lt;InstanceManager*&gt;instanceManagers;</div>
<div class="line"><a class="code" href="namespace_ogre.html#a5c4c0c56ea9f824c49e331f6fad33ddb">MeshPtr</a> mesh =MeshManager::getSingleton().load(<span class="stringliteral">&quot;myMesh.mesh&quot;</span>);</div>
<div class="line"><span class="keywordflow">for</span>(<a class="code" href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">uint16</a> i=0;i&lt;mesh-&gt;getNumSubMeshes();++i )</div>
<div class="line">{</div>
<div class="line">    InstanceManager *mgr =</div>
<div class="line">        mSceneMgr-&gt;createInstanceManager(<span class="stringliteral">&quot;MyManager&quot;</span>+StringConverter::toString(i ),</div>
<div class="line">                    <span class="stringliteral">&quot;myMesh.mesh&quot;</span>,</div>
<div class="line">                ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME,</div>
<div class="line">                    InstanceManager::HWInstancingVTF,numInstancePerBatch,</div>
<div class="line">                    flags,i );</div>
<div class="line">    instanceManagers.push_back(mgr );</div>
<div class="line">}</div>
</div><!-- fragment --><p>The second step lies in sharing the transform with one of the submeshes (which will be named 'master'; i.e. the first submesh) to improve performance and reduce RAM consumption when creating the Instanced Entities:</p>
<div class="fragment"><div class="line">SceneNode *sceneNode;<span class="comment">//Asumed to be valid ptr</span></div>
<div class="line">std::vector&lt;InstancedEntity*&gt;instancedEntities;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;instanceManagers.size();++i )</div>
<div class="line">{</div>
<div class="line">    InstancedEntity *ent =instanceManagers[i]-&gt;createInstancedEntity(<span class="stringliteral">&quot;MyMaterial&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(i !=0)</div>
<div class="line">        instancedEntities[0]-&gt;shareTransformWith(ent );</div>
<div class="line"> </div>
<div class="line">    sceneNode-&gt;attachObject(ent );</div>
<div class="line">    instancedEntities.push_back(ent );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that it is perfectly possible that each <code>InstancedEntity</code> based on a different "submesh" uses a different material. Selecting the same material won't cause the InstanceManagers to get batched together (though the RenderQueue will try to reduce state change reduction, like with any normal Entity).</p>
<p>Because the transform is shared, animating the master InstancedEntity (in this example, <code>instancedEntity[0]</code>) will cause all other slave instances to follow the same animation.</p>
<p>To destroy the instanced entities, use the normal procedure:</p>
<div class="fragment"><div class="line">SceneNode *sceneNode;<span class="comment">//Asumed to be valid ptr</span></div>
<div class="line">std::vector&lt;InstancedEntity*&gt;instancedEntities;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;instanceManagers.size();++i )</div>
<div class="line">{</div>
<div class="line">    instanceManagers[i]-&gt;destroyInstancedEntity(instancedEntities[i]);</div>
<div class="line">}</div>
<div class="line">mSceneMgr-&gt;getRootSceneNode()-&gt;removeAndDestroyChild(sceneNode );</div>
</div><!-- fragment --><h1><a class="anchor" id="InstancingDefragmentingBatches"></a>
Defragmenting batches</h1>
<h2><a class="anchor" id="InstancingDefragmentingBatchesIntro"></a>
What is batch fragmentation?</h2>
<p>There are two kinds of fragmentation:</p>
<ol type="1">
<li>"Deletion" Fragmentation is when many instances have been created, spanning multiple batches; <em>and many of them got later removed</em> but they were all from different batches. If there were 10 instances per batch, 100 instances created, then later 90 removed; it is possible that now there are 10 batches with one instance each (which equals 10 drawcalls); instead of being just 1 batch with 10 instances (which equals 1 drawcall).</li>
<li>"Culling" Fragmentation is also when many instances of different batches are all sparsed across the whole scene. If they were defragmented, they would've been put together in the same batch (all instances sorted by proximity to each other should be in the same batch) to take advantage of hierachy culling optimizations.</li>
</ol>
<p>Defragmented batches can dramatically improve performance:</p>
<p>Suppose there 50 instances per batch, and 100 batches total (which means 5000 instanced entities of the same mesh with same material), and they're all moving all the time.</p>
<p>Normally, <a class="el" href="namespace_ogre.html">Ogre</a> first updates all instances' position, then their AABBs; and while at it, computes the AABB for each batch that encloses all of its instances.</p>
<p>When frustum culling, we first cull the batches, then we cull their instances[^9] (that are inside those culled batches). <b>This is the typical hierachial culling optimization</b>. We then upload the instances transforms to the GPU.</p>
<p>After moving many instances around the whole world, they will make the batch' enclosing AABB bigger and bigger. Eventually, every batch' AABB will be so large, that wherever the camera looks, all 100 batches will end up passing the frustum culling test; thus having to resort to cull all 5000 instances individually.</p>
<h2><a class="anchor" id="InstancingDefragmentingBatchesPrevention"></a>
Prevention: Avoiding fragmentation</h2>
<p>If you're creating static objects that won't move (i.e. trees), create them sorted by proximity. This helps both types of fragmentation:</p>
<ol type="1">
<li>When unloading areas (i.e. open world games), these objects will be removed all together, thus whole batches will no longer have active instances.</li>
<li>Batches and instances are often assigned by order of creation. Those instances will belong to the same batch and thus maximizing culling efficiency.</li>
</ol>
<h2><a class="anchor" id="InstancingDefragmentingBatchesOnTheFly"></a>
Cure: Defragmenting on the fly</h2>
<p>There are cases where preventing fragmentation, for example units in an RTS game. By design, all units may end up scattering and moving from one extreme of the scene to the other after hours of gameplay; additionally, lots of units may be in an endless loop of creation and destroying, but if the loop for a certain type of unit is broken; it is possible to end up with the kind of "Deletion" Fragmentation too.</p>
<p>For this reason, the function <code>InstanceManager::defragmentBatches( bool optimizeCulling )</code> exists.</p>
<p>Using it as simple as calling the function. <b>The sample NewInstancing shows how to do this interactively</b>. When <code>optimizeCulling</code> is true, both types of fragmentation will be attempted to be fixed. When false, only the "deletion" kind of fragmentation will be fixed.</p>
<p>Take in mind that when <code>optimizeCulling = true</code> it takes significantly more time depending on the level of fragmentation and could cause framerate spikes, even stalls. Do it sparingly and profile the optimal frequency of calling.</p>
<h1><a class="anchor" id="InstancingTroubleshooting"></a>
Troubleshooting</h1>
<dl class="section user"><dt>Q: My mesh doesn't show up.</dt><dd>A: Verify you're using the right material, the vertex shader is set correctly, and it matches the instancing technique being used.</dd></dl>
<dl class="section user"><dt>Q: My animation plays quite differently than when it is an Entity, or previewed in Ogre Mesh Viewer.</dt><dd>A: Your rig animation must be using more than one weight per bone. You need to add support for it in the vertex shader, and make sure you didn't create the instance manager with the flags <a class="el" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2ac4105c2b84b7dfd08e4bfa35a5ea9848" title="Use one weight per vertex when recommended (i.e.">Ogre::IM_USEONEWEIGHT</a> or <a class="el" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a7f599ab5ea537d8bab3af8aef358fe0a" title="All techniques are forced to one weight per vertex.">Ogre::IM_FORCEONEWEIGHT</a>.</dd></dl>
<p>For example, to modify the HW VTF vertex shader, you need to sample the additional matrices from the VTF:</p>
<div class="fragment"><div class="line">float2uv0       :   TEXCOORD0;</div>
<div class="line"><span class="comment">// Up to four weights per vertex. Don&#39;t use this shader on a model with 3 weights per vertex, or 2 or 1</span></div>
<div class="line">float4m03_0 :   TEXCOORD1;<span class="comment">//m03.w is always 0</span></div>
<div class="line">float4m03_1 :   TEXCOORD2;</div>
<div class="line">float4m03_2 :   TEXCOORD3;</div>
<div class="line">float4m03_3 :   TEXCOORD4;</div>
<div class="line">float4mWeights  :   TEXCOORD5;</div>
<div class="line"> </div>
<div class="line">float2mOffset   :   TEXCOORD6;</div>
<div class="line"> </div>
<div class="line">float3x4worldMatrix[4];</div>
<div class="line">worldMatrix[0][0] =tex2D(matrixTexture, m03_0.xw +mOffset );</div>
<div class="line">worldMatrix[0][1] =tex2D(matrixTexture, m03_0.yw +mOffset );</div>
<div class="line">worldMatrix[0][2] =tex2D(matrixTexture, m03_0.zw +mOffset );</div>
<div class="line"> </div>
<div class="line">worldMatrix[1][0] =tex2D(matrixTexture, m03_1.xw +mOffset );</div>
<div class="line">worldMatrix[1][1] =tex2D(matrixTexture, m03_1.yw +mOffset );</div>
<div class="line">worldMatrix[1][2] =tex2D(matrixTexture, m03_1.zw +mOffset );</div>
<div class="line"> </div>
<div class="line">worldMatrix[2][0] =tex2D(matrixTexture, m03_2.xw +mOffset );</div>
<div class="line">worldMatrix[2][1] =tex2D(matrixTexture, m03_2.yw +mOffset );</div>
<div class="line">worldMatrix[2][2] =tex2D(matrixTexture, m03_2.zw +mOffset );</div>
<div class="line"> </div>
<div class="line">worldMatrix[3][0] =tex2D(matrixTexture, m03_3.xw +mOffset );</div>
<div class="line">worldMatrix[3][1] =tex2D(matrixTexture, m03_3.yw +mOffset );</div>
<div class="line">worldMatrix[3][2] =tex2D(matrixTexture, m03_3.zw +mOffset );</div>
<div class="line"> </div>
<div class="line">float4 worldPos = float4(mul(worldMatrix[0], inPos ).xyz, 1.0f )* mWeights.x;</div>
<div class="line">worldPos +=float4(mul(worldMatrix[1], inPos ).xyz, 1.0f )* mWeights.y;</div>
<div class="line">worldPos +=float4(mul(worldMatrix[2], inPos ).xyz, 1.0f )* mWeights.z;</div>
<div class="line">worldPos +=float4(mul(worldMatrix[3], inPos ).xyz, 1.0f )* mWeights.w;</div>
<div class="line"> </div>
<div class="line">float4 worldNor = float4(mul(worldMatrix[0], inNor ).xyz, 1.0f )* mWeights.x;</div>
<div class="line">worldNor +=float4(mul(worldMatrix[1], inNor ).xyz, 1.0f )* mWeights.y;</div>
<div class="line">worldNor +=float4(mul(worldMatrix[2], inNor ).xyz, 1.0f )* mWeights.z;</div>
<div class="line">worldNor +=float4(mul(worldMatrix[3], inNor ).xyz, 1.0f )* mWeights.w;</div>
</div><!-- fragment --><p>As you can witness, a HW VTF vertex shader with 4 weights per vertex needs a lot of texture fetches. Fortunately they fit the texture cache very well; nonetheless it's something to keep watching out.</p>
<p>Instancing is meant for rendering large number of objects in a scene. If you plan on rendering thousands or tens of thousands of animated objects with 4 weights per vertex, don't expect it to be fast; no matter what technique you use to draw them.</p>
<p>Try convincing the art department to lower the animation quality or just use <a class="el" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a7f599ab5ea537d8bab3af8aef358fe0a" title="All techniques are forced to one weight per vertex.">Ogre::IM_FORCEONEWEIGHT</a> for <a class="el" href="namespace_ogre.html">Ogre</a> to do the downgrade for you. There are many plugins for popular modeling packages (3DS Max, Maya, Blender) out there that help automatizing this task.</p>
<dl class="section user"><dt>Q: The instance doesn't show up, or when playing animations the mesh deforms very weirdly or other very visible artifacts occur</dt><dd></dd></dl>
<p>A: Your rig uses more than one weight per vertex. Either create the instance manager with the flag <a class="el" href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a7f599ab5ea537d8bab3af8aef358fe0a" title="All techniques are forced to one weight per vertex.">Ogre::IM_FORCEONEWEIGHT</a>, or modify the vertex shader to support the <em>exact</em> amount of weights per vertex needed (see previous questions).</p>
<dl class="section user"><dt>Q: How do I find how many weights per vertices is using my model?</dt><dd></dd></dl>
<p>A: The quickest way is by looking at the type of <a class="el" href="group___render_system.html#gga0a62b3f2ede8992ff365bb013a8bc00da63d3494547f373f5c4397a41b39cf6a0" title="Blending weights.">Ogre::VES_BLEND_WEIGHTS</a>, where <code>VET_FLOAT&lt;N&gt;</code> means N weights.</p>
<p>[^7]: Whether it is actually faster than HW VTF depends on the GPU architecture</p>
<p>[^8]: In theory all other techniques could implement custom parameters but for performance reasons only HW VTF is well suited to implement it. Though it yet remains to be seen whether it should be passed to the shader through the VTF, or through additional TEXCOORDs.</p>
<p>[^9]: Only HW instancing techniques cull per instance. SW instancing techniques send all of their instances, zeroing matrices of those instances that are not in the scene. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespace_ogre_html_a739a289a4d5235f5f509a1795f5ffd5b"><div class="ttname"><a href="namespace_ogre.html#a739a289a4d5235f5f509a1795f5ffd5b">Ogre::Vector4</a></div><div class="ttdeci">Vector&lt; 4, Real &gt; Vector4</div><div class="ttdef"><b>Definition:</b> OgrePrerequisites.h:248</div></div>
<div class="ttc" id="anamespace_ogre_html_a5c4c0c56ea9f824c49e331f6fad33ddb"><div class="ttname"><a href="namespace_ogre.html#a5c4c0c56ea9f824c49e331f6fad33ddb">Ogre::MeshPtr</a></div><div class="ttdeci">SharedPtr&lt; Mesh &gt; MeshPtr</div><div class="ttdef"><b>Definition:</b> OgrePrerequisites.h:286</div></div>
<div class="ttc" id="agroup___general_html_gga4921efc65b347efe08a6d4992af069e2a0ef5ea7756d41449148c181eef505d92"><div class="ttname"><a href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a0ef5ea7756d41449148c181eef505d92">Ogre::IM_USEALL</a></div><div class="ttdeci">@ IM_USEALL</div><div class="ttdef"><b>Definition:</b> OgreCommon.h:371</div></div>
<div class="ttc" id="anamespace_ogre_html_a2a820cf8746c0f12999d2416c767f55d"><div class="ttname"><a href="namespace_ogre.html#a2a820cf8746c0f12999d2416c767f55d">Ogre::uint16</a></div><div class="ttdeci">uint16_t uint16</div><div class="ttdef"><b>Definition:</b> OgrePlatform.h:282</div></div>
<div class="ttc" id="agroup___general_html_gga4921efc65b347efe08a6d4992af069e2a2e31b097f5510963d742dce628d868ef"><div class="ttname"><a href="group___general.html#gga4921efc65b347efe08a6d4992af069e2a2e31b097f5510963d742dce628d868ef">Ogre::IM_VTFBONEMATRIXLOOKUP</a></div><div class="ttdeci">@ IM_VTFBONEMATRIXLOOKUP</div><div class="ttdoc">Use a limited number of skeleton animations shared among all instances.</div><div class="ttdef"><b>Definition:</b> OgreCommon.h:361</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="_instancing.html">Instancing</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
